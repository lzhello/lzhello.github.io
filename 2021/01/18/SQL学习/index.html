<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础编程知识学习," />





  <link rel="alternate" href="/atom.xml" title="lzhello的碎碎念" type="application/atom+xml" />






<meta name="description" content="一. mysql存储引擎 &#x3D; { MyISAM 和 InnoDB的区别} 【是否支持行锁】  MyISAM 仅支持表锁， InnoDB支持表锁和行锁  【是否支持事务】  MyISAM不支持事务，且不具备【崩溃恢复能力】。  InnoDB 支持事务，提供回滚和崩溃恢复。  【是否支持外键】  仅InnoDB支持外键   【是否支持MVCC】  仅InnoDB支持MVCC  【应用场景不同】">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL学习">
<meta property="og:url" content="https://github.com/lzhello/lzhello.github.io.git/2021/01/18/SQL%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="lzhello的碎碎念">
<meta property="og:description" content="一. mysql存储引擎 &#x3D; { MyISAM 和 InnoDB的区别} 【是否支持行锁】  MyISAM 仅支持表锁， InnoDB支持表锁和行锁  【是否支持事务】  MyISAM不支持事务，且不具备【崩溃恢复能力】。  InnoDB 支持事务，提供回滚和崩溃恢复。  【是否支持外键】  仅InnoDB支持外键   【是否支持MVCC】  仅InnoDB支持MVCC  【应用场景不同】">
<meta property="og:locale">
<meta property="article:published_time" content="2021-01-18T10:26:41.000Z">
<meta property="article:modified_time" content="2021-02-21T10:50:35.717Z">
<meta property="article:author" content="lzhello">
<meta property="article:tag" content="基础编程知识学习">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/lzhello/lzhello.github.io.git/2021/01/18/SQL学习/"/>





  <title>SQL学习 | lzhello的碎碎念</title>
  








<meta name="generator" content="Hexo 5.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lzhello的碎碎念</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/lzhello/lzhello.github.io.git/2021/01/18/SQL%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lzhello的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SQL学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-18T18:26:41+08:00">
                2021-01-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/18/SQL%E5%AD%A6%E4%B9%A0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/SQL%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <font size =3 >

<h3 id="一-mysql存储引擎-MyISAM-和-InnoDB的区别"><a href="#一-mysql存储引擎-MyISAM-和-InnoDB的区别" class="headerlink" title="一. mysql存储引擎 = { MyISAM 和 InnoDB的区别}"></a>一. mysql存储引擎 = { MyISAM 和 InnoDB的区别}</h3><ol>
<li><p>【是否支持行锁】<br>  MyISAM 仅支持表锁， InnoDB支持表锁和行锁</p>
</li>
<li><p>【是否支持事务】<br>  MyISAM不支持事务，且不具备【崩溃恢复能力】。<br>  InnoDB 支持事务，提供回滚和崩溃恢复。</p>
</li>
<li><p>【是否支持外键】<br>  仅InnoDB支持外键 </p>
</li>
<li><p>【是否支持MVCC】<br>  仅InnoDB支持MVCC</p>
</li>
<li><p>【应用场景不同】<br>  MyISAM 适用 【Select】频繁，并发少<br>  InnoDB 适用 【Insert Delete Update】频繁，高并发</p>
<p>  因为<br>  (1) MyISAM 仅缓存索引块，而InnoDB缓存 {索引+数据}<br>  (2) InnoDB 回表需要映射块，而MyISAM 直接映射数据地址<br>  (3) InnoDB 需要维护MVCC机制</p>
</li>
</ol>
<pre><code>    6. MyISAM索引 和 InnoDB 索引 区别

    InnoDB 【主键索引】 叶子节点 = &#123;主键ID ， data数据&#125;
    因此 InnoDB根据【主键】索引查询，不需要二次寻址，效率更高

    InnoDB 【二级索引】 叶子节点 = &#123;key, 主键ID&#125;
    如果过实现索引覆盖，即 要查询列值 全部命中索引，则直接返回 非主键索引的内容
    如果为实现索引覆盖，则需要根据【主键ID】做回表

    【存储结构不同】
    InnoDB 存储结构 = 索引和数据 集中存储
    MyISAM存储结构 = &#123;表定义，MYD数据文件，MYI索引文件&#125;

6. 不带WHERE条件时，【count(*)效率不同 】
    MyISAM 自带计数器存储保存【总行数】，可直接返回结果
    InnoDB 扫描全表计算总行数    </code></pre>
<a id="more"></a>

<h3 id="二-事务特性"><a href="#二-事务特性" class="headerlink" title="二. 事务特性"></a>二. <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?type=content&q=%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7">事务特性</a></h3><p>事务符合 ACID原则的一组操作 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. Atomicity</span><br><span class="line">    事务是不可分割的最小单元，事务内所有操作要么全部执行成功，要么全部失败回滚</span><br><span class="line"></span><br><span class="line">2. Isolation</span><br><span class="line">    事务所作出的修改，在提交前，对于其他事务而言不可见</span><br><span class="line">    </span><br><span class="line">3. Durability</span><br><span class="line">    事务一旦提交，所作出的修改是永久的。</span><br><span class="line">    </span><br><span class="line">4. Consistency</span><br><span class="line">    系统从一个正确状态--&gt;另一个正确状态</span><br><span class="line">    AID是数据库的特征，通过AID手段保证C这个目的</span><br><span class="line">    </span><br><span class="line">   【数据库】约束列值 不能小于0，则事务执行失败</span><br><span class="line">   【应用层】约束 余额数据不能小于0，则应用层通过事务回滚保证约束</span><br><span class="line">   </span><br><span class="line">   没有约束，则事务执行成功，且保持了一致性。因为没有破坏约束。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="三-并发事务带来的问题-1630-1700"><a href="#三-并发事务带来的问题-1630-1700" class="headerlink" title="三. 并发事务带来的问题 1630 - 1700"></a>三. 并发事务带来的问题 1630 - 1700</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 脏读 </span><br><span class="line">    事务A 修改数据，但并未commit。而事务B读取该数据。 </span><br><span class="line">2. 丢失修改</span><br><span class="line">    事务A 、B都读取同一个数据。事务A 、B先后修改数据，则 第一次修改操作丢失。</span><br><span class="line">3. 不可重复读</span><br><span class="line">    事务A 共读取两次数据，而在这两次读取之间。事务B修改了数据。则事务A两次读取到的数据不同。</span><br><span class="line">4. 幻读 </span><br><span class="line">    事务A 读取【n行数据】,事务B在n行数据间添加数据。则事务A第二次读取时，读取到n+1行。</span><br></pre></td></tr></table></figure>
<h4 id="！！四-事务隔离级别-1801"><a href="#！！四-事务隔离级别-1801" class="headerlink" title="！！四.  事务隔离级别 1801"></a>！！四.  事务隔离级别 1801</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. Read-Uncommitted 读取未提交</span><br><span class="line">    无论事务是否提交，直接【读取主记录】 </span><br><span class="line">    即并发问题 &#x3D;【脏读】+【不可重复读】+【幻影读】</span><br><span class="line">2. Read-committed 读取已提交</span><br><span class="line">    【读取最新版本的快照】，快照是事务提交后产生，但可能存在同一事务两次读取的快照不同。</span><br><span class="line">    即并发问题 &#x3D; 【不可重复读】+【幻影读】</span><br><span class="line">3. Repeatable 可重复读</span><br><span class="line">    【读取指定版本快照】，则事务多次读取某数据行的结果一致，但读取到的数据可能并非最新数据 。</span><br><span class="line">    即并发问题 &#x3D; 【幻影读】</span><br><span class="line">4. Serializable 可串行化 </span><br><span class="line">    上表锁，读写相互阻塞。效率低下。</span><br><span class="line">    无并发问题 </span><br><span class="line">    </span><br><span class="line">InnoDB引擎默认实现 可重复读隔离级别 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="！！五-MVCC-1655"><a href="#！！五-MVCC-1655" class="headerlink" title="！！五. MVCC 1655"></a>！！五. MVCC 1655</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【目的】 ： </span><br><span class="line">    MVCC是行锁的变种，它想要尽可能地避免加锁操作，实现【非阻塞】读。从而提高处理并发事务的性能</span><br><span class="line"></span><br><span class="line">【MVCC 实现的隔离级别】</span><br><span class="line">    MVCC仅 Read Committed &amp; REPEATABLE READ 两种隔离级别</span><br><span class="line">    READ UNCOMMITTED 总是【读取最新】数据行 ，与MVCC的版本快照机制不符</span><br><span class="line">    SERIALIZABLE 则 对读取的【数据行】都加锁 ，与MVCC 尽可能避免加锁的原则不符</span><br><span class="line">    </span><br><span class="line">【undolog】 记录数据行的某个历史版本，undolog以链表形式存在</span><br><span class="line"></span><br><span class="line">RC 是读取 最新版本的 undolog</span><br><span class="line">RR 是读取 某一指定老版本的undolog</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="！！-六-索引"><a href="#！！-六-索引" class="headerlink" title="！！ 六. 索引"></a>！！ 六. 索引</h4><p>索引的存储结构 = {<br>    1. Hash表<br>    2. B+树<br>}</p>
<h5 id="！6-1-hash索引"><a href="#！6-1-hash索引" class="headerlink" title="！6.1 hash索引"></a>！6.1 hash索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1) hash 索引的实现 </span><br><span class="line">    底层数据结构 &#x3D; hash表</span><br><span class="line">    通过hash值定位数据行，产生碰撞则采用拉链法解决。</span><br><span class="line">(2) hash索引的缺点 </span><br><span class="line">    1. 适用于等值查询。</span><br><span class="line">       但hash索引无法排序，因此不适用于范围查询，不支持最左匹配原则。</span><br><span class="line">    2. 大量重复的键值，减低效率、</span><br></pre></td></tr></table></figure>
<h5 id="6-2-磁盘预读取"><a href="#6-2-磁盘预读取" class="headerlink" title="6.2 磁盘预读取"></a>6.2 磁盘预读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">磁盘读取以【磁盘块】为基本单位。</span><br><span class="line">【磁盘预读取】：每次读取多个【物理连续】的磁盘块</span><br><span class="line">B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。</span><br><span class="line">一页空间 &#x3D; 磁盘预读取的 多个磁盘块总和</span><br><span class="line">从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="！！6-3-为什么使用B-树，而不是-B树"><a href="#！！6-3-为什么使用B-树，而不是-B树" class="headerlink" title="！！6.3 为什么使用B+树，而不是 B树 "></a>！！6.3 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21993785/article/details/80580679">为什么使用B+树，而不是 B树 </a></h5><pre><code>1.  Mysql根据【磁盘IO次数】衡量查询效率，而【B+树磁盘IO次数更少】

    因为 B+树中【 非叶节点 = &#123; 指针+key &#125; 】
    而B树中 【非叶节点 = &#123; 指针+ key + data数据 &#125;】,
    每个节点(即每一页) 存储空间有限，B树节点存储的key较少，出度较小
    因此B树的节点较多(key总量固定)
    导致B树深度较大，磁盘IO次数多。

2.  B+树叶子节点通过指针连接，便于【区间访问】</code></pre>
<h5 id="！！6-4-为什么使用-B-树，而不是红黑树"><a href="#！！6-4-为什么使用-B-树，而不是红黑树" class="headerlink" title="！！6.4 为什么使用 B+树，而不是红黑树"></a>！！6.4 为什么使用 B+树，而不是红黑树</h5><pre><code>【B+树磁盘IO次数更少】 
1.  红黑树的深度往往较大，而磁盘IO次数是和树高度成正比。
2.  
    B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。
    一页空间 = 磁盘预读取的 多个磁盘块总和
    从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数

    红黑树上逻辑较近的节点，其物理距离可能较远。无法利用磁盘预读特性</code></pre>
<h2 id="​"><a href="#​" class="headerlink" title="​        "></a>​        </h2><h5 id="6-5-聚簇索引和-非聚簇索引-主键索引和二级索引"><a href="#6-5-聚簇索引和-非聚簇索引-主键索引和二级索引" class="headerlink" title="!! 6.5 聚簇索引和 非聚簇索引  主键索引和二级索引"></a>!! 6.5 聚簇索引和 非聚簇索引  主键索引和二级索引</h5><h5 id="聚簇索引和非聚簇索引-【区别】"><a href="#聚簇索引和非聚簇索引-【区别】" class="headerlink" title="聚簇索引和非聚簇索引 【区别】"></a>聚簇索引和非聚簇索引 【区别】</h5><h6 id="聚簇索引-将索引结构和数据放在一起的索引"><a href="#聚簇索引-将索引结构和数据放在一起的索引" class="headerlink" title="聚簇索引 = 将索引结构和数据放在一起的索引"></a>聚簇索引 = 将索引结构和数据放在一起的索引</h6><pre><code>【优点】：查询效率高，定位到索引树叶节点，就直接找到数据
【缺点】： 索引列更新时，维护代价大
【主键索引】属于【聚簇索引】</code></pre>
<hr>
<h6 id="非聚簇索引-索引结构和数据分离的索引"><a href="#非聚簇索引-索引结构和数据分离的索引" class="headerlink" title="非聚簇索引 = 索引结构和数据分离的索引"></a>非聚簇索引 = 索引结构和数据分离的索引</h6><pre><code>【优点】： 更新代价小 
【缺点】： 需要二次查询，
        例如 二级索引需要在主键索引中再次回表查询
【二级索引】属于【非聚簇索引】</code></pre>
<hr>
<h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主键索引 叶子节点 &#x3D; &#123;key,其他data数据&#125; </span><br><span class="line"></span><br><span class="line">InnoDB中如果没有指定表的主键，则检测表是否有唯一索引</span><br><span class="line">如果有，则该字段默认 &#x3D; 主键</span><br><span class="line">如果没有， 则InnoDB自动创建6B的自增主键</span><br></pre></td></tr></table></figure></code></pre>
<hr>
<h6 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二级索引 叶子节点 &#x3D; &#123;key，主键ID&#125;</span><br><span class="line"></span><br><span class="line">二级索引查询【过程】</span><br><span class="line">    1. 【非聚集索引】中查询到主键ID</span><br><span class="line">    2. 【回表】 ： 根据主键ID在  【聚集索引】中查询整行记录</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="​-1"><a href="#​-1" class="headerlink" title="​        "></a>​        </h2><h5 id="6-6-最左前缀"><a href="#6-6-最左前缀" class="headerlink" title="!! 6.6 最左前缀"></a>!! 6.6 最左前缀</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">联合索引 是由多个列组成。如(name,age)</span><br><span class="line">查询时，列值【从左到右】匹配索引。</span><br><span class="line">遇到【范围查询】(&gt; &lt; between like左匹配)后 ，不可进一步匹配。</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h5 id="6-7-覆盖索引"><a href="#6-7-覆盖索引" class="headerlink" title="6.7 覆盖索引"></a>6.7 覆盖索引</h5><pre><code>在非聚集索引的叶子节点中 所含的列值是要查询的列值，不用进行回表。直接返回即可</code></pre>
<h5 id="6-8-为什么不对每个列创建索引"><a href="#6-8-为什么不对每个列创建索引" class="headerlink" title="6.8 为什么不对每个列创建索引"></a>6.8 为什么不对每个列创建索引</h5><pre><code>1. 数据CRUD时， 索引需要动态维护
2. 索引占据物理空间，尤其聚簇索引</code></pre>
<hr>
<h4 id="七-数据库三大范式"><a href="#七-数据库三大范式" class="headerlink" title="七.  数据库三大范式"></a>七.  数据库三大范式</h4><p>第一范式： 每个列不可分离<br>第二范式： 非主键<strong>完全依赖</strong>主键<br>第三范式： 非主键<strong>只依赖</strong>主键，不依赖非主键</p>
<h4 id="八-索引应用场景"><a href="#八-索引应用场景" class="headerlink" title="八. 索引应用场景"></a>八. 索引应用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE add index(字段名) 创建索引</span><br><span class="line">    1. WHERE </span><br><span class="line">    WHERE 筛选字段进行查询时，</span><br><span class="line">    如果 该字段建立索引，则查询效率更高</span><br><span class="line">    </span><br><span class="line">    2. ORDER BY  </span><br><span class="line">   </span><br><span class="line">    使用order by将查询结果按照某个字段排序时，</span><br><span class="line">    </span><br><span class="line">    如果该字段没有建立索引，</span><br><span class="line">    查询出的所有数据使用外部排序，涉及磁盘IO，则效率底下</span><br><span class="line">    </span><br><span class="line">    ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br><span class="line">    由于索引有序，所以按照索引顺序逐条读出数据</span><br><span class="line">    </span><br><span class="line">    3. 索引覆盖</span><br><span class="line">    【查询的字段】都建立过索引，</span><br><span class="line">    引擎会直接在索引表中查询而【不访问原始数据】</span><br><span class="line">    尽可能在select后只写必要的查询字段，以增加索引覆盖的几率</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="九-创建索引的原则"><a href="#九-创建索引的原则" class="headerlink" title="九. 创建索引的原则"></a>九. 创建索引的原则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 字段 基数大</span><br><span class="line">2. 字段 重复值较少 </span><br><span class="line">3. 字段 频繁作为【查询条件】</span><br><span class="line">4. 字段 更新少 </span><br><span class="line">5. 最左匹配原则 ：  </span><br><span class="line">    MySQL对 索引中的列值 从左到右匹配，直到遇到范围查询就停止</span><br><span class="line">6. 尽量扩展索引，而非创建新索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="十-大表优化"><a href="#十-大表优化" class="headerlink" title="十.  大表优化"></a>十.  大表优化</h4><h5 id="explain-查看执行计划-，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等"><a href="#explain-查看执行计划-，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等" class="headerlink" title="explain 查看执行计划 ，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等"></a>explain 查看执行计划 ，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</h5><h5 id="1-大表优化"><a href="#1-大表优化" class="headerlink" title="1. 大表优化"></a>1. 大表优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 限定数据范围 </span><br><span class="line">    查询语句 通过查询条件限定数据范围</span><br><span class="line">2. 数据库主从同步，读写分离</span><br><span class="line">    多个服务器上部署mysql，</span><br><span class="line">    一台服务器为【主库】，负责【写数据】</span><br><span class="line">    其他服务器为【从库】，负责【读数据】</span><br><span class="line">    </span><br><span class="line">    一. 主从同步实现</span><br><span class="line">    【主库A】数据库事件存储在 日志系统A中，传输日志文件</span><br><span class="line">    【从库】 接收文件并写入本地日志系统，然后将【数据库事件】在从库MySQL中完成</span><br><span class="line"></span><br><span class="line">3. 垂直分区</span><br><span class="line">    </span><br><span class="line">    优点：一行记录 的数据量变少，在查询时IO次数减少</span><br><span class="line">    </span><br><span class="line">    缺点：</span><br><span class="line">        (1) 主键冗余，</span><br><span class="line">        (2) 引起join操作</span><br><span class="line">4. 水平分区</span><br><span class="line">    将 【行数据】分组存储到不同【库 ||表】， 【最好分库】</span><br><span class="line">    </span><br><span class="line">    【缺点】：</span><br><span class="line">        (1) 查询时，通常需要 【多个表名】 + 【UNION操作】</span><br><span class="line">        (2) 跨库 JOIN 性能很差 , </span><br><span class="line">        (3) 【跨库】的【事务支持】，逻辑复杂度和性能代价 都很大</span><br><span class="line"></span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<hr>
<h5 id="2-分表-分库后的问题"><a href="#2-分表-分库后的问题" class="headerlink" title="2. 分表 分库后的问题"></a>2. 分表 分库后的问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1). 【跨节点】的 count，order by ， group by 等【聚合函数】逻辑复杂</span><br><span class="line">(2). 【跨库】的join 性能代价大</span><br><span class="line">(3). 【主键ID问题】 ：MySQL原先主键自增机制，跨库情况下，存在主键重复的问题</span><br><span class="line">   1)  若采用 UUID作为主键， 则UUID主键占用内存过大</span><br><span class="line">   2)  多个数据库采用 跨步自增</span><br><span class="line">   3) ...</span><br><span class="line">(4) 【事务支持】</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="3-主从分布，读写分离"><a href="#3-主从分布，读写分离" class="headerlink" title="3. 主从分布，读写分离"></a>3. 主从分布，读写分离</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用 &#x3D; &#123; 负载均衡 + 数据备份 + 高可用&#125;</span><br><span class="line">流程 &#x3D;&#123;</span><br><span class="line">    1. 主库的【数据库事件】记录在二进制的binlog，binlog传输给从库</span><br><span class="line">    2. 从库读取binlog内容到本地日志系统的relaylog</span><br><span class="line">    3. 从库 执行relay log中的SQL语句，实现主从同步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十一-SQL生命周期"><a href="#十一-SQL生命周期" class="headerlink" title="十一. SQL生命周期"></a>十一. SQL生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 应用服务器与数据库服务器建立一个连接，应用服务器发送SQL请求</span><br><span class="line"></span><br><span class="line">2. 数据库进程拿到【sql请求】，通过【连接器】验证SQL语句是否具有【权限】</span><br><span class="line"></span><br><span class="line">3. 【分析器】进行 词法分析和语法分析。 </span><br><span class="line">    词法分析 提取SQL语句关键元素 ： SELECT 、 表名 、 查询条件等</span><br><span class="line">    语法分析 判断SQL语句是否正确 ：判断关键词是否正确</span><br><span class="line"></span><br><span class="line">4. 【优化器】生成SQL【执行计划】</span><br><span class="line">    </span><br><span class="line">5. 【执行器】按照执行计划， 将数据读取到内存并进行逻辑处理</span><br><span class="line"></span><br><span class="line">6. 通过连接，将数据传输给应用服务器 </span><br><span class="line"></span><br><span class="line">7. 断开连接</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="十二-MySQL锁"><a href="#十二-MySQL锁" class="headerlink" title="十二. MySQL锁"></a>十二. MySQL锁</h4><h5 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1. 表锁"></a>1. 表锁</h5><h5 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2. 行锁"></a>2. 行锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Record Lock :  单个数据行的锁</span><br><span class="line">2. Gap Lock ： 锁定范围，不包括记录本身</span><br><span class="line">3. Next-key lock : record + gap 结合，锁定一个范围，并且锁定记本身</span><br></pre></td></tr></table></figure>
<h4 id="十三-count-count1-count-col-区别-1050-1110"><a href="#十三-count-count1-count-col-区别-1050-1110" class="headerlink" title="十三. count* count1 count(col)区别  1050 - 1110"></a>十三. count* count1 count(col)区别  1050 - 1110</h4><h5 id="count-expression-聚合函数"><a href="#count-expression-聚合函数" class="headerlink" title="count(expression) = 聚合函数"></a>count(expression) = 聚合函数</h5><pre><code>逐行检测expression是否=null, 
expression！=null则计数器加1</code></pre>
<h5 id="count-1-和count-作用相同"><a href="#count-1-和count-作用相同" class="headerlink" title="count(1)和count(*)作用相同:"></a>count(1)和count(*)作用相同:</h5><pre><code>count(1) 每行expression=1 ，NOT NULL，count(1)作用=统计总行数
count(*) 并非 统计每行所有列值是否为null，列值全为null的数据行不存在.
因此 count(*) = 统计总行数</code></pre>
<h5 id="count-1-count-经过优化器指定的执行计划相同-，两者效率相同"><a href="#count-1-count-经过优化器指定的执行计划相同-，两者效率相同" class="headerlink" title="count(1) count(*) 经过优化器指定的执行计划相同 ，两者效率相同"></a>count(1) count(*) 经过优化器指定的执行计划相同 ，两者效率相同</h5><pre><code>在没有二级索引情况下， 通过主键索引统计总行数
如果有二级索引， 则优先选择 【最窄】二级索引统计总行数 
主键索引 叶节点 = &#123;主键ID, 其他所有列值&#125;
二级索引 叶节点 = &#123;key+主键ID&#125; </code></pre>
<h5 id="count-col-逐行检测col是否-null"><a href="#count-col-逐行检测col是否-null" class="headerlink" title="count(col) 逐行检测col是否=null"></a>count(col) 逐行检测col是否=null</h5><pre><code>因此 count(col)统计 非null列的总行数
对col建立非聚集索引，可以优化查询效率</code></pre>
<h4 id="十四-explain-返回的结果"><a href="#十四-explain-返回的结果" class="headerlink" title="十四. explain 返回的结果"></a>十四. <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuxineli/article/details/14455029">explain 返回的结果</a></h4><h5 id="type-【引擎查找表】的方式"><a href="#type-【引擎查找表】的方式" class="headerlink" title="type 【引擎查找表】的方式"></a>type 【引擎查找表】的方式</h5><pre><code>all,index,range,ref,eq_ref，const
从左到右，它们的效率依次是增强的

all     全表扫描
index   全索引扫描
range   范围扫描 ：     【索引】+【范围查询】
ref     小范围扫描：    【可能重复】的【普通索引】+【表联结情况】
eq_ref  单条数据扫描 ： 【主键 || 唯一】索引+【表联结情况】
const   单条数据扫描 ： 【主键 || 唯一】索引 </code></pre>
<p>​    </p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><pre><code>MySQL 使用的索引</code></pre>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><pre><code>MYSQL 执行查询的行数，数值越大性能越差 </code></pre>
<h5 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h5><pre><code>Using index 使用覆盖索引
Using Where 使用WHERE过滤
Using temporary ： 使用临时表 ，建议优化
Using filesort ： 对查询结果【外部排序】，而非根据索引有序读取。建议优化 </code></pre>
<hr>
<h4 id="十五-SQL优化-1020"><a href="#十五-SQL优化-1020" class="headerlink" title="十五. SQL优化 1020"></a>十五. SQL优化 1020</h4><h4 id="一-WHERE的优化"><a href="#一-WHERE的优化" class="headerlink" title="(一). WHERE的优化"></a>(一). WHERE的优化</h4><h5 id="1-全表扫描"><a href="#1-全表扫描" class="headerlink" title="1.全表扫描"></a>1.全表扫描</h5><p>WHERE,ORDER BY涉及的列上 建立索引 </p>
<h5 id="2-WHERE条件中避免使用的判断"><a href="#2-WHERE条件中避免使用的判断" class="headerlink" title="2.WHERE条件中避免使用的判断"></a>2.WHERE条件中避免使用的判断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    is null ,</span><br><span class="line">    !&#x3D;  ,</span><br><span class="line">    OR  ,</span><br><span class="line">    in  ,   &#x2F;&#x2F;  慎重使用，非连续 in集合会放弃索引，全表扫描</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些判断，会使得引擎【放弃索引】，进行【全表扫描】</p>
<h5 id="3-WHERE条件中-避免【运行时解析】的变量"><a href="#3-WHERE条件中-避免【运行时解析】的变量" class="headerlink" title="3. WHERE条件中 避免【运行时解析】的变量"></a>3. WHERE条件中 避免【运行时解析】的变量</h5><p>原因： 执行计划在【<strong>编译期</strong>】制定，【<strong>运行时解析</strong>】的变量不能作为索引输入项<br>因此采用全表扫描  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    1. 参数 </span><br><span class="line">         WHERE num &#x3D; @num</span><br><span class="line">    2. WHERE条件左侧 避免 函数调用+算术计算 </span><br><span class="line">        WHERE num &#x3D; 100+2</span><br><span class="line">        WHERE substring(num,1,3) &#x3D; &#39;abc&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="十六-超大分页"><a href="#十六-超大分页" class="headerlink" title="十六. 超大分页"></a>十六. 超大分页</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">超大分页 &#x3D; Limit 10000，10 </span><br><span class="line">MySQL并非跳过&#x3D; offset行，而是取offset+N行，然后返回放弃前offset行，返回N行</span><br><span class="line">那当offset特别大的时候，效率低下</span><br><span class="line"></span><br><span class="line">【优化方法】： 先快速定位 主键，然后再关联</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="十七-SQL优化"><a href="#十七-SQL优化" class="headerlink" title="十七. SQL优化"></a>十七. SQL优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 慢查询日志 ，查看开销大的SQL</span><br><span class="line">    set GLOBAL slow_query_log &#x3D; on</span><br><span class="line">2.  开销大原因 &#x3D; &#123;</span><br><span class="line">    1.  </span><br><span class="line">        【原因一】：SQL语句 是否加载额外的数据 </span><br><span class="line">        【例子】： 未使用WHERE范围限制、 Limit分页过大、 使用&#123;is NULL，!&#x3D; ，OR&#125; 触发全表扫描</span><br><span class="line">        【优化】 ： 修改SQL语句</span><br><span class="line">        </span><br><span class="line">    2. </span><br><span class="line">        【原因二】： 未命中索引、使用的索引有待优化</span><br><span class="line">        【例子】： SELECT A,B,C FROM t WHERE A&#x3D;? AND B&#x3D; ? </span><br><span class="line">                    或者 ORDER BY 、ON的列上是否建立索引 </span><br><span class="line">        【优化】：explain查询执行计划，创建||选择其他索引，使得SQL语句尽可能地命中索引</span><br><span class="line">        </span><br><span class="line">    3. </span><br><span class="line">        【原因三】： SQL语句无法优化，【大表情况】</span><br><span class="line">            (1) 分库分表</span><br><span class="line">            (2) 主从同步，读写分离</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" rel="tag"># 基础编程知识学习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/12/firstblog/" rel="next" title="firstblog">
                <i class="fa fa-chevron-left"></i> firstblog
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/18/java%E5%AD%A6%E4%B9%A0/" rel="prev" title="java学习">
                java学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lzhello" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="lzhelloo@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-MyISAM-%E5%92%8C-InnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">一. mysql存储引擎 &#x3D; { MyISAM 和 InnoDB的区别}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="nav-text">二. 事务特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98-1630-1700"><span class="nav-text">三. 并发事务带来的问题 1630 - 1700</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%81%EF%BC%81%E5%9B%9B-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-1801"><span class="nav-text">！！四.  事务隔离级别 1801</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%81%EF%BC%81%E4%BA%94-MVCC-1655"><span class="nav-text">！！五. MVCC 1655</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%81%EF%BC%81-%E5%85%AD-%E7%B4%A2%E5%BC%95"><span class="nav-text">！！ 六. 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%816-1-hash%E7%B4%A2%E5%BC%95"><span class="nav-text">！6.1 hash索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB%E5%8F%96"><span class="nav-text">6.2 磁盘预读取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%81%EF%BC%816-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF-B%E6%A0%91"><span class="nav-text">！！6.3 为什么使用B+树，而不是 B树 </span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%81%EF%BC%816-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">！！6.4 为什么使用 B+树，而不是红黑树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%8B"><span class="nav-text">​        </span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-5-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">!! 6.5 聚簇索引和 非聚簇索引  主键索引和二级索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E3%80%90%E5%8C%BA%E5%88%AB%E3%80%91"><span class="nav-text">聚簇索引和非聚簇索引 【区别】</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E5%B0%86%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-text">聚簇索引 &#x3D; 将索引结构和数据放在一起的索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-text">非聚簇索引 &#x3D; 索引结构和数据分离的索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-text">主键索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">二级索引</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%8B-1"><span class="nav-text">​        </span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-6-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80"><span class="nav-text">!! 6.6 最左前缀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-7-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-text">6.7 覆盖索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E6%AF%8F%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-text">6.8 为什么不对每个列创建索引</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%83-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-text">七.  数据库三大范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AB-%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">八. 索引应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%9D-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-text">九. 创建索引的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81-%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-text">十.  大表优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#explain-%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E7%AD%89"><span class="nav-text">explain 查看执行计划 ，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-text">1. 大表优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%88%86%E8%A1%A8-%E5%88%86%E5%BA%93%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">2. 分表 分库后的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%B8%BB%E4%BB%8E%E5%88%86%E5%B8%83%EF%BC%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-text">3. 主从分布，读写分离</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-SQL%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">十一. SQL生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C-MySQL%E9%94%81"><span class="nav-text">十二. MySQL锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A1%A8%E9%94%81"><span class="nav-text">1. 表锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A1%8C%E9%94%81"><span class="nav-text">2. 行锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E4%B8%89-count-count1-count-col-%E5%8C%BA%E5%88%AB-1050-1110"><span class="nav-text">十三. count* count1 count(col)区别  1050 - 1110</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#count-expression-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-text">count(expression) &#x3D; 聚合函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#count-1-%E5%92%8Ccount-%E4%BD%9C%E7%94%A8%E7%9B%B8%E5%90%8C"><span class="nav-text">count(1)和count(*)作用相同:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#count-1-count-%E7%BB%8F%E8%BF%87%E4%BC%98%E5%8C%96%E5%99%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9B%B8%E5%90%8C-%EF%BC%8C%E4%B8%A4%E8%80%85%E6%95%88%E7%8E%87%E7%9B%B8%E5%90%8C"><span class="nav-text">count(1) count(*) 经过优化器指定的执行计划相同 ，两者效率相同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#count-col-%E9%80%90%E8%A1%8C%E6%A3%80%E6%B5%8Bcol%E6%98%AF%E5%90%A6-null"><span class="nav-text">count(col) 逐行检测col是否&#x3D;null</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B-explain-%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-text">十四. explain 返回的结果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#type-%E3%80%90%E5%BC%95%E6%93%8E%E6%9F%A5%E6%89%BE%E8%A1%A8%E3%80%91%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">type 【引擎查找表】的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#key"><span class="nav-text">key</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rows"><span class="nav-text">rows</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#extra"><span class="nav-text">extra</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E4%BA%94-SQL%E4%BC%98%E5%8C%96-1020"><span class="nav-text">十五. SQL优化 1020</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80-WHERE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">(一). WHERE的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="nav-text">1.全表扫描</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-WHERE%E6%9D%A1%E4%BB%B6%E4%B8%AD%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-text">2.WHERE条件中避免使用的判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-WHERE%E6%9D%A1%E4%BB%B6%E4%B8%AD-%E9%81%BF%E5%85%8D%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A7%A3%E6%9E%90%E3%80%91%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text">3. WHERE条件中 避免【运行时解析】的变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%85%AD-%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5"><span class="nav-text">十六. 超大分页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E4%B8%83-SQL%E4%BC%98%E5%8C%96"><span class="nav-text">十七. SQL优化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      


<div id="music163player">
 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1349927611&auto=0&height=66"></iframe>
</div>




<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width:100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" rel="tag">基础编程知识学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/" rel="tag">我的项目</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a><span class="tag-list-count">3</span></li></ul>
        </canvas>
    </div>
</div>

</div>
</aside>





        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzhello</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">18.7k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





<span id="sitetime"></span>
<script language=javascript>
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var t1 = Date.UTC(2018,06,07,12,00,00); // 设置建立网站的时间
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }
  siteTime();
</script>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'GtCtI94yO18eQvvJRre7GbmU-gzGzoHsz',
        appKey: '7Bc7UDA3574iWiw9pGgRc8VS',
        placeholder: 'Just go go',
        avatar:'/images/avatar.png',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
