<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lzhello的碎碎念</title>
  
  
  <link href="https://github.com/lzhello/lzhello.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/lzhello/lzhello.github.io.git/"/>
  <updated>2021-03-16T16:28:10.581Z</updated>
  <id>https://github.com/lzhello/lzhello.github.io.git/</id>
  
  <author>
    <name>lzhello</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020暑假的虎牙小程序开发大赛--Emojito.live的诞生</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/03/17/2020%E6%9A%91%E5%81%87%E7%9A%84%E8%99%8E%E7%89%99%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%A4%A7%E8%B5%9B-Emojito-live%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/03/17/2020%E6%9A%91%E5%81%87%E7%9A%84%E8%99%8E%E7%89%99%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%A4%A7%E8%B5%9B-Emojito-live%E7%9A%84%E8%AF%9E%E7%94%9F/</id>
    <published>2021-03-16T16:19:11.000Z</published>
    <updated>2021-03-16T16:28:10.581Z</updated>
    
    <content type="html"><![CDATA[<p>开坑+1，不开坑的话我觉得我肯定就懒得写了。</p><p>很有趣的一个项目，因为抱上了编程大佬诺神的大腿，还稀里糊涂地让特别贴心和温暖的央语学妹当了队长，包揽了所有除编程外的各类比赛事项，所以整个项目过程中我基本就是从开头划水划到最后，真是愧为学姐。不过这个项目是我第一个得以上线试验过的项目（虽然没有得到投入使用的机会），在这点上，比起以前的纸上谈兵项目（比如大作业那个只能在自己本地电脑上运行起来的电商购物网站），这个项目值得一提的程度就变得非常高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开坑+1，不开坑的话我觉得我肯定就懒得写了。&lt;/p&gt;
&lt;p&gt;很有趣的一个项目，因为抱上了编程大佬诺神的大腿，还稀里糊涂地让特别贴心和温暖的央语学妹当了队长，包揽了所有除编程外的各类比赛事项，所以整个项目过程中我基本就是从开头划水划到最后，真是愧为学姐。不过这个项目是我第一个</summary>
      
    
    
    
    
    <category term="我的项目" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>2020小学期--由古老的servlet+jsp+HTML技术构成的购物网站</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/03/17/2020%E5%B0%8F%E5%AD%A6%E6%9C%9F-%E7%94%B1%E5%8F%A4%E8%80%81%E7%9A%84servlet-jsp-HTML%E6%8A%80%E6%9C%AF%E6%9E%84%E6%88%90%E7%9A%84%E8%B4%AD%E7%89%A9%E7%BD%91%E7%AB%99/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/03/17/2020%E5%B0%8F%E5%AD%A6%E6%9C%9F-%E7%94%B1%E5%8F%A4%E8%80%81%E7%9A%84servlet-jsp-HTML%E6%8A%80%E6%9C%AF%E6%9E%84%E6%88%90%E7%9A%84%E8%B4%AD%E7%89%A9%E7%BD%91%E7%AB%99/</id>
    <published>2021-03-16T16:06:16.000Z</published>
    <updated>2021-03-22T15:15:09.941Z</updated>
    
    <content type="html"><![CDATA[<p>开个坑，等托福考完再回来写，隔壁北科的高中同学这学期有个作业也要写购物网站，为了帮他写作业（我真是带好人）所以这几天把工程文件都翻了出来，刚好这学期把博客开起来了，那就来记录记录我的第一个充斥着血汗泪水和菜鸡技术的编程项目。</p><hr><p>总算是考完了托福首考……考完感觉人都升华了……那么现在开始写博客。</p><p>2020年是很不平凡的一年，因为新冠的原因，我的整个大二下学期都是在家里度过的，在自己房间里上学校的网课是什么效果懂的都懂，所以我名正言顺地摸了一个学期的鱼，连最后的期末都是线上考试，让我的期末周也过得像摸鱼，如果说要在这摸鱼的半年里选一件最累的事，可能就是这个小学期吧。期末刚考完没几天，我们被拉进一个叫做”design and building”的群聊，开始在李晶老师的指导下零基础学习网页开发以及标题提到的java pages, servlet, JavaScript, HTML和CSS等等技术。</p><p><img src="http://i2.tiimg.com/734918/4637a71d7243dd7e.jpg" alt="因为加群的同学的id实在太应景而留下的一张截图"></p><a id="more"></a><hr><h2 id="开头：胡乱摸索的一个星期"><a href="#开头：胡乱摸索的一个星期" class="headerlink" title="开头：胡乱摸索的一个星期"></a>开头：胡乱摸索的一个星期</h2><p>第一节课是熟悉的装环境搞配置，在大二的时候我们只开了java编程课，大部分人电脑里用的编译器都是eclipse（我发现自己依然不记得这个词怎么拼，醉了），但是老师说，如果要开发，用IDEA是个更好的选择，于是开始上课的第一天，我们组的三个小白花了半个上午去下载盗版IDEA。事实证明这是个很值得的事，因为<strong>用了IDEA才知道IDEA多好用</strong>，当用eclipse的同学在为集成数据库捣鼓的时候，在IDEA里只需要点一下右边的一小排，使用体验非常良好。</p><p>除了编译器，第一节还教了<strong>Tomcat</strong>的下载和使用，啊，localhost8080，我命运般的8080，你不知道我开始那几天为你受了多少苦.jpg。老师在群里放了两个网页开发的小例子，大概就是输入用户名，输入密码，点击登录，跳转界面，很简单的几个步骤，我捣鼓了两天硬是没跑起来，IDEA的properties的设置没调好，jdbc的密码没改等等现在看起来很弱智的问题当时每一个都让人很头大，对着各种CSDN和博客园调整了很久，最后终于成功能在输入用户名和密码时跳转到另外一个界面。很难形容当时的欣喜心情，这个要是写起来就有点长了，在此略过。</p><p>配完环境的第一步工作是确认需要做些什么网页。老师给的官方建议是仨人分俩去写后端，还有一个去写（套）前（模）端（板），我是俩后端之一，主要负责三个大的页面的后台逻辑：<strong>商品的列表展示、详细信息查看和添加购物车；购物车的生成和内容删改；以及订单的生成、管理、列表展示和详细信息查看</strong>。三个页面的关系非常紧密，于是我从商品的列表展示，购物网站最基本的功能之一开始做起了。我们的整体架构完全是照着老师给的那个登陆的例子抄的（没有一丝更高端一点的东西），分了三层和一个工具包：</p><p><strong>dao层用来放各种操作的函数，entity层用来放各种实体，servlet层用来根据页面传回来的method值判断需要实现的功能，util里存了各个层都能用的用来连接和关闭数据库的方法。</strong>（你以为我的util层里会有md5之类的加密手段别的高端操作吗，并没有，只有单纯的连接和关闭数据库，够纯）</p><p><img src="http://i2.tiimg.com/734918/de54d7d5ba1383f3.png"></p><p>小学期的作业是分两次验收的，第一次就是这一周“速成”后马上验收一次，第二次是下个学期开学时整体作品验收。在“速成”阶段验收的时候，上图所列出来的各大.java文件我有五分之四都是空的，写了东西并且能用的只有<strong>ProductDao, Product, ProductServlet和ConnectDB</strong>，是的，手忙脚乱的一个星期过后，我实现的功能只有商品展示，商品详细信息展示，商品的模糊搜索，商品的排序。</p><p><img src="http://i1.fuimg.com/734918/64b765f0146bf3eb.png" alt="中期验收的报告"></p><p>（现在看当时的实验报告真是公开处刑）</p><p>我（没几步的）工作步骤是：</p><ol><li>按老师给的要求（顺便砍掉几个不好写的）建立数据库的表，随便编几个数据；</li><li>在entity里写product，把数据库表里的东西都一一对应进去；</li><li>在dao里写需要用到的函数，把需要的商品信息装进ArrayList（几个函数不一样的地方只有那句executeQuery里的MySQL语句）;</li><li>让servlet得到ArrayList，然后在response里传入新建的product.jsp页面；</li><li>在jsp页面里用for循环逐个打印。</li></ol><p><img src="http://i2.tiimg.com/734918/1f52248c3aa955ab.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开个坑，等托福考完再回来写，隔壁北科的高中同学这学期有个作业也要写购物网站，为了帮他写作业（我真是带好人）所以这几天把工程文件都翻了出来，刚好这学期把博客开起来了，那就来记录记录我的第一个充斥着血汗泪水和菜鸡技术的编程项目。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总算是考完了托福首考……考完感觉人都升华了……那么现在开始写博客。&lt;/p&gt;
&lt;p&gt;2020年是很不平凡的一年，因为新冠的原因，我的整个大二下学期都是在家里度过的，在自己房间里上学校的网课是什么效果懂的都懂，所以我名正言顺地摸了一个学期的鱼，连最后的期末都是线上考试，让我的期末周也过得像摸鱼，如果说要在这摸鱼的半年里选一件最累的事，可能就是这个小学期吧。期末刚考完没几天，我们被拉进一个叫做”design and building”的群聊，开始在李晶老师的指导下零基础学习网页开发以及标题提到的java pages, servlet, JavaScript, HTML和CSS等等技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.tiimg.com/734918/4637a71d7243dd7e.jpg&quot; alt=&quot;因为加群的同学的id实在太应景而留下的一张截图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="我的项目" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>托福学习 listening</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/03/16/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-listening/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/03/16/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-listening/</id>
    <published>2021-03-16T09:35:58.000Z</published>
    <updated>2021-03-17T09:00:50.378Z</updated>
    
    <content type="html"><![CDATA[<p>讲座+对话</p><a id="more"></a><h3 id="主旨题"><a href="#主旨题" class="headerlink" title="主旨题"></a>主旨题</h3><p>key words:</p><p>排除原则：比较、变化、上节课内容、细节、反向</p><h3 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h3><p>1 conversation, 3 minutes, 5 questions</p><p>problem-solving:</p><ol><li>提出问题：直接引出（回答/未回答)、间接引出</li><li>分析问题：围绕问题展开讨论的新信息（提问+因果，并列，第三者，态度和语气)</li><li>解决问题</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;讲座+对话&lt;/p&gt;</summary>
    
    
    
    
    <category term="英语" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>托福学习-reading</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/</id>
    <published>2021-03-10T08:36:06.000Z</published>
    <updated>2021-03-17T09:09:41.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构式阅读法"><a href="#结构式阅读法" class="headerlink" title="结构式阅读法"></a>结构式阅读法</h3><p>skimming ＞＞ scanning</p><p>考察频率最高的文章类型：生命科学类，历史类，社会类，考古类</p><a id="more"></a><h3 id="词汇题"><a href="#词汇题" class="headerlink" title="词汇题"></a>词汇题</h3><p>顺逻辑： ，（）；：are, and, so that(原因在so that前), by(原因在by后), since, -that, also</p><p>逆逻辑： <strong>neg</strong>ligible - no逆逻辑对应， although,  while（大多时候表示转折）, by comparison, whereas</p><ol><li><p>The most widely <strong>accepted</strong> theory, <u>championed</u> by anthropologists in the late nineteenth and early twentieth centuries, envisions theater as emerging out of myth and ritual. </p><p>championed 最近义词： changed/ debated / created / <strong>supported</strong></p><p>因为逗号顺逻辑→和accepted意思相近→排除前两个反意思的→accept的不一定是create的，但create的一定是accept的，create被accept包含；support与accept范围更相近</p></li><li><p>if it seems difficult to conceive how major <strong>changes</strong> could occur rapidly, consider this: an <u>alteration</u> of a single gene in files is enough to turn a normal fly with a single pair of wings into one that has two pairs of wings. </p><p>alteration最近义词：imperfection/ replacement/ <strong>change</strong>/ duplication</p><p>逗号和冒号都是顺逻辑→ imperfection, replacement和duplication 都是change的一种，意思被包含，故选change</p></li><li><p>Another seemingly <u>plausible</u> explanation –that infants do not form enduring memories at this point in development –also is incorrect.</p><p>plausible最近义词： flexible/ <strong>believable</strong>/ debatable/ predictable</p><p>–that –also都是顺逻辑→ 前段意思和incorrect一样→seemingly XXX 通常实际表反义（他看起来是个好人→他不是个好人）→seemingly plausible表示incorrect, plausible表示correct</p></li></ol><p>词汇前后缀</p><ul><li>neg-逆逻辑</li><li>in- 否定</li><li>pro- 前，进，伸</li><li>uni- 唯一，一致</li><li>ex- 否定，外向</li><li>com- co- 共同</li><li>var- 变化</li><li>terr- 地面，地况</li><li>de- 否</li><li>im- 不能</li></ul><h3 id="细节题-事实信息题"><a href="#细节题-事实信息题" class="headerlink" title="细节题 事实信息题"></a>细节题 事实信息题</h3><p>According to paragraph X, ……..</p><p>定位词，关键词</p><p>选项与题目与文章对应：主干要对，逻辑要对</p><p>虚假绝对逻辑，虚假否定逻辑，虚假比较逻辑，虚假上下逻辑，虚假因果逻辑，虚假转折逻辑，虚假并列逻辑</p><p>时间和地点：定位词+逻辑分割点</p><p>无、反、混、偏、满</p><p>绝对词＜比较＜上升/下降</p><p>永远最后验证最有可能错的选项（绝对词）</p><p>选项中可能存在（关键词的选择原则）    </p><ol><li><p>转折</p><ul><li>转折 however, rather than, instead of , but ,yet, on the other hand, unfortunately, nevertheless</li><li>让步 although, after all, in spite of… , despite, even if, even though, admittedly</li></ul></li><li><p>对比</p><p>by contrast, on the contrary, contradict, while, whereas, however, unlike,</p></li><li><p>因果</p><ul><li>原因 for this reason, due to, thanks to</li><li>结果 evidently, effect, thus,hence, therefore, accordingly, consequentlt</li><li>结尾 therefore, as a result, then, consequently</li><li>结论 in a word, in conclusion, therefore</li></ul></li><li><p>态度观点词</p><ul><li>正面 emphasize, illustrate, acknowledge, explain, account for</li><li>负面 question, argue against, refute</li><li>中性 present/pose, introduce,indicate, conclude, reveal </li></ul></li><li><p>顺序</p></li><li><p>判断</p></li><li><p>比较选择（与文中的动词替换）</p><ul><li>not a ,but rather b</li><li>no longer a but b</li><li>not a ,instead b</li></ul></li><li><p>上升下降，绝对词……</p></li></ol><p>隐性因果关系词：通过（by），由于（out of），导致（bring…to…），时间（when）</p><p>逻辑分割后，在明显分割线以外的部分出现的词都不对</p><p>因果/果因分清楚：A as B = B so A(B是因，A是果)</p><p>结构阅读 + 关键词选择 + 逻辑细节分割</p><h3 id="否定事实信息题"><a href="#否定事实信息题" class="headerlink" title="否定事实信息题"></a>否定事实信息题</h3><p>According to ……., which of the following is <strong>NOT</strong> true of ….? The author …. <strong>EXCEPT</strong>…</p><p>特点</p><ul><li>对应原文某一处描述（通常为举例：注意include等分类逻辑词） （大多情况）</li><li>对应原文两处/两处以上描述，通常为分散举例/排比（未被选择的选项应该和原文构成一一对应）</li><li>顺序性</li></ul><p><strong>选项</strong>核心定位</p><ul><li>一次性找出四个选项的定位词</li><li>全部记在纸上</li><li>每浏览段落的1-2句话，交叉对比四个选项的定位词</li><li>一旦一个选项锁定，留意附近是否有其它选项</li></ul><h3 id="推理题"><a href="#推理题" class="headerlink" title="推理题"></a>推理题</h3><p>infer/ imply / suggest / indicate / most likely</p><p>细节题+正/反向推断</p><p>反向推理：转折词，否定词，反义词，时间地点（出现这四个信号词，优先从反推入手）</p><p>反推选项 主干信息，否定/反义逻辑</p><p>优先看并列（多信息）</p><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Documents\lzhelloblog\lzhelloblog\source_posts\托福学习-reading\QQ截图20210314194313.png" alt="QQ截图20210314194313"></p><p>LF 负面(unfulfilling) artist ＞ entertainer  →  <em>由负面推断</em>  事实: entertain ＞ art </p><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210314205619.png" alt="QQ截图20210314205619"></p><p>英国商人operate credit → 推理出 其他非英国人 not operate credit  →  选项 most European not operate</p><h3 id="句子简化题"><a href="#句子简化题" class="headerlink" title="句子简化题"></a>句子简化题</h3><p>文中一个长句子被阴影标出来 Which of the sentences below best express the essential information in the highlighted sentence in the passage? Incorrect choice change the meaning in important ways or leave out essential information.</p><p>步骤</p><ol><li>逻辑词判断</li><li>内容判断<ol><li>主干内容</li><li>次要内容</li></ol></li></ol><p>否定：明显（no, not, none, never, neither, deny），隐含（fail to, absent from, lack, lack of, refuse)</p><p>因果：明显（because, since, for, as, due to, owing to), 隐含（come from, result from, derive from, initiate from; reflect, present, suggest, show,imply, demonstrate; considering, on account of, in view of, rely on; when, while, as long as)</p><p>比较：同类比较/比较级， 隐含（change, vary, alter, modify, revise, increase; same, different; surpass,exceed,transcend, excel）</p><p>最高级/绝对化 ： 明显， 隐含（自身有最高级含义：maximum,minimum, outstanding, extreme； 程度深的词 surpriseingly, amazingly,prohibitively）</p><p><strong>错误选项</strong>： 极端词、虚假逻辑、细节过分放大、引入原文未出现的逻辑/内容、缺少核心逻辑/内容</p><p><strong>居中原则</strong> 当句子中出现多个逻辑词的时候，从最靠近句子中部位置的逻辑词入手</p><p>这类题目中，给的题干句子通常是逻辑的组合（比如 并列+因果，转折+因果等），则可以排除缺少组合中的某一种逻辑的选项。</p><p>题干句子没有什么特别的逻辑的情况下，选项可能会自己添加逻辑（虚假的转折，因果），排除</p><p>not only…. but also…. 并列逻辑</p><p>破折号里面的细节内容</p><h3 id="指代题"><a href="#指代题" class="headerlink" title="指代题"></a>指代题</h3><p>The word XXX in the passage refers to?</p><ol><li>语法原则：单复数一致，人称一致 </li><li>前置原则：正确答案必在所考代词之前（优先主语，其次最近信息-主干信息）</li><li>句内原则：正确答案与所考代词通常出现在<strong>同一句内</strong>，除非代词位于句首/出现指代的传递</li><li>语义原则：代入并翻译成中文验证</li></ol><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210315145357.png" alt="QQ截图20210315145357"></p><p>not only… but also… 并列，所以BC不对</p><p>修饰成分非主干，不选</p><h3 id="修辞目的题"><a href="#修辞目的题" class="headerlink" title="修辞目的题"></a>修辞目的题</h3><p><strong>对具体信息目的的提问</strong>：作者举了个例子，题目问作者为什么要举着个例子</p><ul><li>The author discuss X in order to …?</li><li>Why does the author mention X?</li><li>The author uses X as an example of…?</li></ul><p>正确答案通常会包含：论点，论据，论点论据之间的支持/反对关系</p><p>论点论据-核心功能性词汇</p><p>正： to emphasize, to illustrate, to suggest, to provide an example, to cite evidence, to acknowledge</p><p>反： to question, argue against, differentiate/distinguish, compare, contrast, refute, digress, contradict</p><p><strong>对段落目的的提问</strong>： 段落的主旨是？</p><ul><li>what is the purpose of paragraph X?</li><li>what is the structure of paragraph X?</li><li>what is the main point of paragraph X?</li></ul><p><strong>对段间关系的提问</strong>： 某一段和其他段的关系是什么？这一段在全文中有什么作用？(Topic Sentence)</p><ul><li>How is the paragraph X related to other parts of the passage?</li></ul><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210315175122.png" alt="QQ截图20210315175122"></p><p>信息封装- A 如何作用于 B</p><p>作用：逻辑关键词、功能性关键词、both</p><p>验证作用：确定论点论据的角色，确定论点论据的正负逻辑</p><p>隐形例证：信息具体时（具体人物，具体地点，具体时间，具体数据），可判定为论据</p><p>不能破坏封装：XXXX作为一个整体，里面的词不会再出现在选项里</p><p>句段逻辑关系：问题解决型、现象解释型、新老观点对比型</p><h3 id="句子插入题"><a href="#句子插入题" class="headerlink" title="句子插入题"></a>句子插入题</h3><p>衔接手段：词汇，逻辑，语法</p><p>先总再分（线性思维原则）</p><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210316120135.png" alt="QQ截图20210316120135"></p><p>everyday household tasks包括 cliff dwelling, hauling water, woodand food</p><h3 id="主旨题"><a href="#主旨题" class="headerlink" title="主旨题"></a>主旨题</h3><p>最后一个题，选中三个=2分，选中两个=1分</p><p>正确：全文主题、一个或多个段落概述（多为概括性描述，可能找不到对应原文）</p><p>错误：与原文矛盾、原文没有明确提及、过于细枝末节</p><p>10秒蒙：选最长的三个句子</p><p>1-2分钟：精读介绍句，筛选关键词（介绍句的主干，标题，或文章中高频词）</p><p>3分钟+：精度介绍句，review text，记录每段主题句（首尾句）的要点</p><p>排除：</p><ol><li>排除带有解释修饰成分的且修饰对象和内容都为不重要内容的选项</li><li>排除主语为细节的选项</li><li>排除小举例（只提到过一次，未展开，连续列举的举例）</li></ol><p>主要细节：直接支持文章，对理解文章必不可少</p><p>次要细节：支持主要细节，删除后也不影响文章主题</p><h3 id="背景内容"><a href="#背景内容" class="headerlink" title="背景内容"></a>背景内容</h3><h4 id="生物的爆发和灭绝"><a href="#生物的爆发和灭绝" class="headerlink" title="生物的爆发和灭绝"></a>生物的爆发和灭绝</h4><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210316153342.png" alt="QQ截图20210316153342"></p><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210316154705.png" alt="QQ截图20210316154705"></p><p><img src="/lzhello/lzhello.github.io.git/2021/03/10/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-reading/Users\HSKyon\Desktop\图片\QQ截图20210316161751.png" alt="QQ截图20210316161751"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;结构式阅读法&quot;&gt;&lt;a href=&quot;#结构式阅读法&quot; class=&quot;headerlink&quot; title=&quot;结构式阅读法&quot;&gt;&lt;/a&gt;结构式阅读法&lt;/h3&gt;&lt;p&gt;skimming ＞＞ scanning&lt;/p&gt;
&lt;p&gt;考察频率最高的文章类型：生命科学类，历史类，社会类，考古类&lt;/p&gt;</summary>
    
    
    
    
    <category term="英语" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>托福学习 writing</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/03/01/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-writing/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/03/01/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-writing/</id>
    <published>2021-03-01T03:26:14.000Z</published>
    <updated>2021-03-18T16:45:09.779Z</updated>
    
    <content type="html"><![CDATA[<p>英语写作：语言逻辑+语言质量</p><h2 id="独立写作：总分并列"><a href="#独立写作：总分并列" class="headerlink" title="独立写作：总分并列"></a>独立写作：总分并列</h2><p>开头段（60）</p><ul><li>总论点1（160）<ul><li>分论点1</li><li>分论点2</li></ul></li><li>总论点2（160）<ul><li>分论点1</li><li>分论点2</li></ul></li></ul><p>结尾段（60）</p><a id="more"></a><p>图像化题目</p><p><img src="/lzhello/lzhello.github.io.git/2021/03/01/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-writing/Users\HSKyon\Desktop\图片\QQ截图20210301161317.png" alt="QQ截图20210301161317"></p><p>distance learning —————&gt;good</p><p><img src="/lzhello/lzhello.github.io.git/2021/03/01/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-writing/Users\HSKyon\Desktop\图片\QQ截图20210301162548.png" alt="QQ截图20210301162548"></p><p><img src="/lzhello/lzhello.github.io.git/2021/03/01/%E6%89%98%E7%A6%8F%E5%AD%A6%E4%B9%A0-writing/Users\HSKyon\Desktop\图片\QQ截图20210301162942.png" alt="QQ截图20210301162942"></p><p>总观点：在线教育好</p><p>好=对学习好+对个人发展好 <strong>切割逻辑重点</strong></p><p>对学习好：能让学生学习知识，所以好；能激发学生学习兴趣，所以好（理由说，中间环节）</p><p>对个人发展好： 在线教育对坚持不懈有好处；在线教育对人际关系有好处</p><h3 id="开头段"><a href="#开头段" class="headerlink" title="开头段"></a>开头段</h3><h4 id="现象引入"><a href="#现象引入" class="headerlink" title="现象引入"></a>现象引入</h4><p>N，同位语，has been valued and even triggers a heated discussion over 题目改写</p><p>N: 话题词汇/从题目中选择的中性词汇</p><p>同位语： </p><p>1）N为中性词，the foundation of a quality life</p><p>2）N为褒义词，the objective everyone strives for </p><p>题目改写：</p><p>whether/what引导的 名词性从句</p><p>Education, the foundation of a quality life, has been valued and even triggers a heated discussion over whether students should take courses online or in classrooms. </p><h4 id="对方观点"><a href="#对方观点" class="headerlink" title="对方观点"></a>对方观点</h4><p>主语， in some people’s views</p><p>说明观点即可，不需要增加理由</p><h4 id="自己观点"><a href="#自己观点" class="headerlink" title="自己观点"></a>自己观点</h4><p>Contrary to these people’s opinions is my perspective that… , due to …(the contributions to )</p><p>Contrary to these people’s opinions is my perspective that online learning, which requires students to attend classes on computers or televisions, is superior, due to the contributions to their academic performance and personal development.</p><h3 id="中间段"><a href="#中间段" class="headerlink" title="中间段"></a>中间段</h3><h4 id="总论点（概述下文内容）【长句】"><a href="#总论点（概述下文内容）【长句】" class="headerlink" title="总论点（概述下文内容）【长句】"></a>总论点（概述下文内容）【长句】</h4><p><strong>What must be prioritized is that</strong> <em>taking a distance-learning courses,</em> instead of having courses in traditional classrooms, <em>is beneficial to students’ academic learning</em>, by offering them more knowledge and triggering their enthusiasm in learning.</p><p>(对比反驳另外一个观点+提出分论点，与下文呼应)</p><h4 id="分论点1-抽出逻辑链，再进行切割-【短句】"><a href="#分论点1-抽出逻辑链，再进行切割-【短句】" class="headerlink" title="分论点1(抽出逻辑链，再进行切割)【短句】"></a>分论点1(抽出逻辑链，再进行切割)【短句】</h4><p><strong>To begin with</strong>, it is <em>online education</em> that provides students with the access to a large quantity of expertise.</p><p>distance learning ———-&gt;knowledge</p><h4 id="解释1-正面-反面-【长句】"><a href="#解释1-正面-反面-【长句】" class="headerlink" title="解释1(正面+反面)【长句】"></a>解释1(正面+反面)【长句】</h4><p><strong>In detail,</strong> on the Internet, students can acquire a wide range of knowledge in history, art and science, enlarging their knowledge base; <strong>in contrast</strong>, such a large amount of knowledge cannot be obtained when they are instructed by only one teacher in concrete classrooms. </p><p>对比时，针对正面论证写反面（正面：网上可以学到XXXXXX知识，反面：在线下不能学到）</p><h4 id="分论点2【短句】"><a href="#分论点2【短句】" class="headerlink" title="分论点2【短句】"></a>分论点2【短句】</h4><p><strong>Moreover</strong> ,never can we ignore the significance of distance education to students’ interest in learning.</p><p>distance learning———–&gt; interest</p><h4 id="解释2-正面-反面-【长句】"><a href="#解释2-正面-反面-【长句】" class="headerlink" title="解释2(正面+反面)【长句】"></a>解释2(正面+反面)【长句】</h4><p>（下切interest）</p><p><strong>To explain it further,</strong> by receiving education on the Internet, students will find it more interesting to deal with mathematical problems, do research, and write proposals; <strong>on the other hand</strong>, will they be passionate about the tasks when teachers always lecture in brick-and-mortar classrooms?</p><h3 id="中间段2"><a href="#中间段2" class="headerlink" title="中间段2"></a>中间段2</h3><p><strong>What should be equally worth discussing is that</strong> receiving distance education, rather than having traditional face-to-face courses, can promote students’ personal development, by honing their interpersonal skills and cultivating their persistence.</p><p><strong>To begin with</strong>, it is well-acknowledged that educated on the Internet, students can practice their communication skills.</p><p>新逻辑链：distance learning——-&gt;interpersonal</p><p><strong>Specifically</strong>, only in online learning environments will students come across people from backgrounds,such as classmates, instructors and school administrators, with whom they can practice their  socializing; <strong>on the contrary</strong>, under no circumstances will they interact with such a variety of people if they are educated in traditional classroom settings.</p><p><strong>Additionally,</strong> when having a distance education program, students will become more determined.</p><p>新逻辑链： distance learning———-&gt;persistence</p><p><strong>To be more specific</strong>, the more distance-learning courses they take on the Internet, the more distractions they will be exposed to, stimulating them to resist temptations and foster their persistence; <strong>however</strong>, it is impossible for them to encounter these lures in traditional classrooms.</p><h3 id="结尾段"><a href="#结尾段" class="headerlink" title="结尾段"></a>结尾段</h3><h4 id="总结总论点1"><a href="#总结总论点1" class="headerlink" title="总结总论点1"></a>总结总论点1</h4><p>Academic performance, <strong>the foundation of students’ future development</strong>, will be boosted when they receive online education.</p><h4 id="总结总论点2"><a href="#总结总论点2" class="headerlink" title="总结总论点2"></a>总结总论点2</h4><p>Personal development, <strong>essential contributors to students’ future success</strong>, will be facilitated, if they are educated on the Internet.</p><h4 id="总结全文"><a href="#总结全文" class="headerlink" title="总结全文"></a>总结全文</h4><p><strong>To conclude, only be ** having distance education, **instead of ** being taught in classrooms, **can</strong> students reap numerous benefits.  </p><h3 id="模板句式总结"><a href="#模板句式总结" class="headerlink" title="模板句式总结"></a>模板句式总结</h3><p>开头段</p><ol><li>…, 同位语， has been valued and even triggers a heated discussion over…</li><li>…, in many people’s views, …</li><li>Contrary to these people’s opinions is my perspective that … ,due to the contributions to … and …</li></ol><p>中间段</p><ol><li>What must be prioritized is that …/What is equally worth discussing is that…</li><li>Initially, /First, /To begin with,</li><li>To be more specific,/Specifically/ In detail, /To explain it further… + 对比： however/in contrast, /on the contrary / on the other hand</li><li>Moreover/Additionally/Furthermore</li><li>To be more specific,/Specifically/ In detail, /To explain it further… + 对比： however/in contrast, /on the contrary / on the other hand</li></ol><p>结尾段</p><ol><li>…, 同位语， will…</li><li>…, 同位语， will…</li><li>In conclusion , only + 状语 + 半倒装</li></ol><h3 id="主要话题"><a href="#主要话题" class="headerlink" title="主要话题"></a>主要话题</h3><ol><li>教育类<ol><li>学生层面<ol><li>academic learning: more knowledge(1-4); trigger interest(5-7)<ol><li>acquire/gain/obtain/attain academic expertise/knowledge</li><li>broaden/extend/improve/increase knowledge</li><li>sth can provide students with the access to a wide range of/ considerable/comprehensive knowledge</li><li>enrich their knowledge/ enlarge their knowledge base</li><li>excite/ generate/stimulate/trigger/motivate students’ interest/passion/enthusiasm</li><li>participate in/ engage themselves in/ involve themselves in/be engaged in/ be involved in</li><li>allocate/distribute time to doing </li></ol></li><li>skills: interpersonal skills(1-6), time management skills(7,8)<ol><li>extracurricular/after-school activities</li><li>hone/ practice/ develop skills</li><li>cultivate/foster/nurture/shape one’s personalities/characteristics</li><li>interpersonal/communicative/social skills/ tactics/strategies</li><li>converse/ interact/ socialize with sb</li><li>people from assorted/diverse/various/a variety of backgrounds and cultures.</li><li>label and arrange them in the order of urgency</li><li>prioritize task in demand for /demanding/ requiring instant/immediate attention</li></ol></li><li>qualities: independent, persistent(2-5)<ol><li>independence and autonomy/ self-reliance/ self-determination</li><li>confront/ be confronted with/ in the confrontation of</li><li>hardships/ obstacles/adversities/enigmas/frustration/desperation</li><li>persistence/perseverance/grit</li><li>achieve success regardless of/ disregarding any setbacks</li></ol></li><li>professional development: locate careers,(123) promote(45)<ol><li>be competitive in </li><li>win/gain/attain/obtain competitiveness/competitive edges in</li><li>locate/ pursue/ hunt for/ search for career</li><li>get promotion/ advancement</li><li>move up one’s career ladder</li></ol></li></ol></li><li>教师层面<ol><li>benefit students</li><li>benefit teachers<ol><li>teaching methods<ol><li>diverse/assorted/a variety of/ numerous/ excessive/ substantial</li><li>teaching/ pedagogical/ instructional + tactics/approaches/strategies/ techniques</li><li>involve/ engage students in discussions</li><li>increase/boost/enhance + students’ engagement/involvement</li></ol></li><li>achievement/ satisfaction/ motivation<ol><li>a sense of achievement/motivation/attainment/accomplishment</li><li>motivate/ stimulate/ urge/ spur/ inspire sb to do</li></ol></li></ol></li></ol></li><li>学校层面<ol><li>benefit students</li><li>benefit schools<ol><li>enrollment/reputation<ol><li>prestigious/renowned/well-known</li><li>lead to / contribute to / result in enrollment growth</li><li>increase/enhance/boost enrollment rate</li><li>regard/consider as the most essential/vital/decisive/dominant/prominent + element/ingredient/factor/component in their college search process</li></ol></li><li>donation(from alumni, company)<ol><li>a quality/ well-rounded/ decent/ first-class education</li><li>boost/raise/increase a school’s revenue</li><li>build/ establish alumni links</li></ol></li></ol></li></ol></li></ol></li><li>工作类<ol><li>员工层面<ol><li>benefits of high salaries<ol><li>improve one’s professional life</li><li>improve one’s personal life(oneself+family members)–work</li></ol></li><li>benefit of 另一点</li><li>embark on a career(着手工作)</li></ol></li><li>职业生活<ol><li>efficient(reduce time/errors);<ol><li>increase/improve/boost/enhance productivity/efficiency</li><li>lower/undermine/impair/hamper productivity</li><li>eliminate personal distractions/distractors/interruptions 减少干扰</li><li>rectify/correct/revise errors</li><li>decrease the risks/chances/possibilities/likelihoods of errors </li></ol></li><li>relationship(with colleagues/employers/clients)<ol><li>employees/ subordinates/ co-workers/ colleagues/ fellow workers</li><li>render assistance to sb</li><li>move up a career ladder</li><li>sth ensure/guarantee/secure + promotion/advancement</li><li>sb promotion/advancement</li></ol></li></ol></li><li>老板层面<ol><li>efficient: reduce time/ reduce errors</li><li>relationship with subordinates/ clients</li></ol></li><li>公司层面<ol><li>inner operation<ol><li>efficiency</li><li>relationship</li></ol></li><li>external development<ol><li>reputation: attract other</li><li>donation, investment and client</li></ol></li></ol></li></ol></li><li>品质类（品质成功、以貌取人）<ol><li>品质成功<ol><li>efficiency<ol><li>reduce time</li><li>reduce errors(concentrate/misunderstanding)</li></ol></li><li>assistance<ol><li>from parents</li><li>from strangers</li></ol></li><li>triumph/satisfaction/prosperity/success/achievement</li><li>accomplish/achieve/attain/fulfill/meet/reach an objective/target/aim</li><li>pursue their dreams/ in the pursuit of their dreams</li><li>strive for / struggle for + a dream</li><li>realize one’s dream/ reach a dream</li></ol></li><li>以貌取人<ol><li>vary constantly VS personalities<ol><li>mood</li><li>seasons/fashion/ages/living places</li></ol></li><li>uniform<ol><li>at the workplace</li><li>at school</li></ol></li><li>leave a favorable/ good/ positive impression on </li></ol></li></ol></li><li>生活类（健康+朋友+买）<ol><li>health<ol><li>physical health<ol><li>exercise/ do physical activities/ be physically active</li><li>keep a sedentary life/ lead a sedentary lifestyle</li><li>distract/prevent/exclude sb from a sedentary lifestyle</li></ol></li><li>mental health<ol><li>pressure/ tension/ stress</li><li>undergo/ experience/ endure/ suffer from</li><li>cope with/ deal with / handle/ address/ tackle/ combat pressure</li><li>adopt…as a stress-relief/stress-reducing strategy/ adopt… as a stress reducer</li><li>alter one’s stress level(减少压力)</li><li>distract sb from</li><li>daily/ routine worries/concerns/trivia</li><li>happiness/ delight/ elation/ enjoyment/joy/ exhilaration/ contentment</li></ol></li></ol></li><li>relationship<ol><li>new friends<ol><li>build/establish + relationship/connection/bond</li><li>a close/strong/intimate/harmonious bond</li><li>encounter/come across/get acquainted with</li><li>expand/extend one’s current social circle/network</li><li>a wider/larger friend circle</li></ol></li><li>old friends<ol><li>maintain/strengthen relationship/connection/bond</li><li>acquainted friends/ companions</li></ol></li><li>communicate</li><li>assistance</li></ol></li><li>买 切物品<ol><li>students: computers, sport equipment</li><li>adults: mobile phones, automobiles</li><li>professional life: computers, automobiles</li><li>personal life: mobile phones, sports equipment</li></ol></li></ol></li><li>友谊类<ol><li>友谊杀手<ol><li>communication（无法交流）<ol><li>topics</li><li>time</li></ol></li><li>assistance（无法帮助）<ol><li>solve problems in the workplace</li><li>solve problems in the daily life</li></ol></li></ol></li><li>友谊意义</li></ol></li></ol><h2 id="综合概述：对比总分"><a href="#综合概述：对比总分" class="headerlink" title="综合概述：对比总分"></a>综合概述：对比总分</h2><h3 id="笔记记什么？"><a href="#笔记记什么？" class="headerlink" title="笔记记什么？"></a>笔记记什么？</h3><p>专有名词：固定说法，很难找到同义词的名词</p><p>意思（逻辑）</p><p>转折逻辑: however,but,although</p><p>并列逻辑: and, also, moreover, in addition</p><p>总分逻辑: such as, for example, one of which</p><p>因果逻辑: because , so,thus, therefore</p><p>顺序逻辑: first, and then, when, after</p><h4 id="综合写作本质（对比感）"><a href="#综合写作本质（对比感）" class="headerlink" title="综合写作本质（对比感）"></a>综合写作本质（对比感）</h4><p><em>In an academic course, a student might be asked to compare and contract the points of view expressed by the professor in class with those expressed by an author in the assigned reading materials. The student must successfully draw information from each source to explain the contrast</em>.</p><p>读到的东西+上课讲到的东西有什么不同，从材料中提取筛选信息<strong>（专有名词+意思逻辑）</strong>，解释对比</p><h3 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h3><h4 id="开头段-1"><a href="#开头段-1" class="headerlink" title="开头段"></a>开头段</h4><p>主题词，（3个）XX</p><p>读完一整段在做笔记</p><h4 id="中间段-1"><a href="#中间段-1" class="headerlink" title="中间段"></a>中间段</h4><p>TS（主题句）关键词：总分专名（核心细节）</p><p>核心细节→支持中心句的细节</p><h3 id="听力笔记"><a href="#听力笔记" class="headerlink" title="听力笔记"></a>听力笔记</h3><p>TS可能在开头，可能在结尾</p><p>（主）<strong>对比</strong>专名（反驳阅读的专有名词）</p><p>（次）逻辑符号</p><h4 id="开头段-2"><a href="#开头段-2" class="headerlink" title="开头段"></a>开头段</h4><p>记录男女</p><p>听，脑记意思，关注主旨句</p><h4 id="中间段-2"><a href="#中间段-2" class="headerlink" title="中间段"></a>中间段</h4><p>听＞笔记</p><p>尽记录反驳阅读的专有名词（对比专名）+明显简单的逻辑</p><h4 id="补笔记"><a href="#补笔记" class="headerlink" title="补笔记"></a>补笔记</h4><p>3,1,2 的顺序，用汉语串意思，把缩写单词补完整</p><h3 id="综合写作模板结构"><a href="#综合写作模板结构" class="headerlink" title="综合写作模板结构"></a>综合写作模板结构</h3><p><strong>主题（主语从句）</strong> is the focus of both the writer and the professor. In the writing, three 三个TS所属类别，including A,B and C, have been elaborated. The professor, however, claims that 听力主旨.</p><p>As opposed to the writer’s idea that 阅读的TS1, the professor states that 听力的TS1. He/She advances the theory by saying that 听力的细节.</p><p>The professor continues to discredit the writing’s assertion that 阅读TS2, by examining the fact that 听力的TS2. In detail, he/she points out that 听力的细节.</p><p>It is the professor’s third argument that 听力的TS3, which contradicts the view of the writer that 阅读的TS3. To explore deeper, the professor extends that 听力的细节.</p><p>An apparent divide exists between the writer and the professor on 主题（名词）.</p><h3 id="对比意识：听力和阅读的对比内容"><a href="#对比意识：听力和阅读的对比内容" class="headerlink" title="对比意识：听力和阅读的对比内容"></a>对比意识：听力和阅读的对比内容</h3><p>一个细节是否需要写取决于是否有反驳</p><h3 id="读者意识：没有读过阅读没有听过听力的人能看懂"><a href="#读者意识：没有读过阅读没有听过听力的人能看懂" class="headerlink" title="读者意识：没有读过阅读没有听过听力的人能看懂"></a>读者意识：没有读过阅读没有听过听力的人能看懂</h3><p>对文章主题词进行解释，尽可能描述清楚直接</p><p><em>What were the functions of the carved stone balls carved from different types of stones</em> is the focus of both the writer and the professor. In the writing, three <em>uses including weapons, standard weights and social status markers</em> have been elaborated. The professor, however, claims that <em>these purposes are not convincing</em>.</p><ul><li>对主题词进行解释</li><li>including总分逻辑，后面+名词或动词ing</li><li>时态：模板里一般现在时，内容根据具体动作时间判断，如果判断太难，都和阅读保持一致</li></ul><p>第一个理由段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">笔记：</span><br><span class="line">1. weapons: hole, groove, cord</span><br><span class="line">wear</span><br><span class="line">pieces</span><br><span class="line">surface</span><br><span class="line">x wear</span><br><span class="line">x damage</span><br></pre></td></tr></table></figure><p> As opposed to the writer’s idea that <em>carved stone balls could be hunting weapons</em>, the professor states that <em>they lacked signs of wear supposed to appear on weapons</em>. She advances the theory by saying that <em>common weapons generally show wear, for instance, having pieces broken off, but the surfaces of carved stone balls did not show wear of damage</em>.</p><ul><li>不要连续抄阅读的五个词汇，进行词汇变化或句式变化</li><li>听力用自己的话说，但保留对比专名和逻辑关系</li><li>听力的解释用一个句子，可用and, but, or, so 连词，或用分号断句</li><li>对比总分逻辑</li></ul><p>第二个理由段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">笔记：</span><br><span class="line">2. weight measure: size&#x2F;diameter</span><br><span class="line">mass</span><br><span class="line">stones</span><br><span class="line">density</span><br><span class="line">→weight</span><br></pre></td></tr></table></figure><p>The professor continues to discredit the writing’s assertion that <em>carved stone balls, uniform in sizes, could be used to weigh and measure</em> by examining the fact that <em>though having the same sizes, they were different in masses, making it impossible for them to be standard weights</em>. In detail, she points out that <em>carved stone balls were made of different types of stones, with distinct density. Consequently, they, in the uniform size, varied in weight and could not be adopted as weighing systems</em>.</p><p>第三个理由段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">笔记：</span><br><span class="line">3. social: design, status</span><br><span class="line">①. pattern</span><br><span class="line">markings</span><br><span class="line">status system</span><br><span class="line">②. rank</span><br><span class="line">possess</span><br><span class="line">tomb</span><br><span class="line">grave</span><br></pre></td></tr></table></figure><p>It is the professor’s third argument that <em>some balls’ simple patterns and the lack of evidence as possessions indicate that they were not social status markers</em>, which contradicts the view of the writer that <em>they, with intricate designs, could mark their owners’ social status</em>. To explore deeper, the professor contends that <em>admittedly, some balls were carved with elaborate designs, but others had markings that were too simple for balls to be status symbols. <u>Moreover,</u> unlike possessions, which people with high ranks were usually buried with, carved stone balls were not found in tomb or graves, showing that they were not possessions to represent social status.</em></p><p>结尾：</p><p>An apparent divide exists between the writer and the professor on <em>the purposes of carved stone balls</em>.</p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;英语写作：语言逻辑+语言质量&lt;/p&gt;
&lt;h2 id=&quot;独立写作：总分并列&quot;&gt;&lt;a href=&quot;#独立写作：总分并列&quot; class=&quot;headerlink&quot; title=&quot;独立写作：总分并列&quot;&gt;&lt;/a&gt;独立写作：总分并列&lt;/h2&gt;&lt;p&gt;开头段（60）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总论点1（160）&lt;ul&gt;
&lt;li&gt;分论点1&lt;/li&gt;
&lt;li&gt;分论点2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总论点2（160）&lt;ul&gt;
&lt;li&gt;分论点1&lt;/li&gt;
&lt;li&gt;分论点2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结尾段（60）&lt;/p&gt;</summary>
    
    
    
    
    <category term="英语" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>前端 知识学习</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/02/25/%E5%89%8D%E7%AB%AF%20%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/02/25/%E5%89%8D%E7%AB%AF%20%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-02-25T13:20:19.000Z</published>
    <updated>2021-03-01T03:26:44.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端面试中的重要考点"><a href="#前端面试中的重要考点" class="headerlink" title="前端面试中的重要考点"></a>前端面试中的重要考点</h3><ul><li>HTML与CSS</li><li>原型，作用域，异步</li><li>DOM事件与Ajax</li><li>性能优化</li><li>手写代码</li><li>HTTP协议</li></ul><a id="more"></a><p>CSS：布局，定位，移动端响应式</p><p>ES语法：原型&amp;原型链，作用域&amp;闭包，异步&amp;单线程</p><p>Web API： DOM&amp;BOM， Ajax跨域，事件存储</p><p>开发环境：版本管理，调试抓包，打包建构</p><p>运行环境：页面渲染，性能优化，Web安全</p><p>网络通讯： headers，Restful API， 缓存策略</p><h3 id="面试题体验"><a href="#面试题体验" class="headerlink" title="面试题体验"></a>面试题体验</h3><ul><li>typeof能判断的类型？【考点：JS变量类型】</li><li>何时使用===何时使用==？【考点：强制类型转换】</li><li>window.onload和DOMContentLoaded区别？【页面加载过程】</li><li>JS创建10个&lt;a&gt;标签，点击弹出对应序号 【JS作用域】</li><li>手写节流throttle和防抖debounce【性能体验优化】</li><li>Promise解决什么问题？【JS异步】</li></ul><h3 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h3><p>JD分析+简历准备</p><p><a href="http://www.imooc.com/article/300475">面试中应避免的几种情况</a></p><h3 id="HTML-CSS面试题"><a href="#HTML-CSS面试题" class="headerlink" title="HTML+CSS面试题"></a>HTML+CSS面试题</h3><h4 id="HTML面试题"><a href="#HTML面试题" class="headerlink" title="HTML面试题"></a>HTML面试题</h4><ul><li>如何理解HTML语义化</li><li>默认情况下，哪些HTML标签是块级元素，哪些是内联元素</li></ul><h4 id="CSS面试题"><a href="#CSS面试题" class="headerlink" title="CSS面试题"></a>CSS面试题</h4><p>CSS：布局，定位，图文样式，响应式，CSS3</p><p>【布局】</p><ul><li>盒子模型的宽度如何计算？</li><li>margin纵向重叠问题</li><li>margin负值的问题</li><li>BFC的理解与应用</li><li>float布局的问题，clearfix</li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前端面试中的重要考点&quot;&gt;&lt;a href=&quot;#前端面试中的重要考点&quot; class=&quot;headerlink&quot; title=&quot;前端面试中的重要考点&quot;&gt;&lt;/a&gt;前端面试中的重要考点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTML与CSS&lt;/li&gt;
&lt;li&gt;原型，作用域，异步&lt;/li&gt;
&lt;li&gt;DOM事件与Ajax&lt;/li&gt;
&lt;li&gt;性能优化&lt;/li&gt;
&lt;li&gt;手写代码&lt;/li&gt;
&lt;li&gt;HTTP协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="基础编程知识学习" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接 学习</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/02/18/TCP%E8%BF%9E%E6%8E%A5-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/02/18/TCP%E8%BF%9E%E6%8E%A5-%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-02-18T12:55:01.000Z</published>
    <updated>2021-02-24T03:20:03.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网学习"><a href="#计网学习" class="headerlink" title="计网学习"></a>计网学习</h1><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p><strong>关键词</strong><br>面向连接的可靠的传输</p><p>确认ACK（确认号是否有效，一般置为1）：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p><p>同步SYN（请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1）：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p><p>终止FIN（希望断开连接）：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p><a id="more"></a><p>三次握手</p><p>C to S : 建立连接 SYN</p><p>S to C : SYN+ACK</p><p>C to S : ACK</p><p>四次分手（目的是为了让资源不要随意释放）</p><p>C to S : FIN</p><p>S to C : FIN+ACK</p><p>S to C : FIN</p><p>C to S : ACK</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>【1】为什么连接3次握手，断开4次分手</p><p>“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p><p>防止了服务器端的一直等待而浪费资源</p><p>当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，<strong>很可能并不会立即关闭SOCKET</strong>，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>在谢希仁著《计算机网络》书中同时举了一个例子，如下：</p><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，<strong>而是在某个网络结点长时间的滞留了</strong>，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。<strong>这样，server的很多资源就白白浪费掉了</strong>。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><p>【2】为什么不能连接时2次握手</p><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p>为了保证服务端S能收接受到客户端C的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p><h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h2><p>ip+port 唯一表示</p><p>ip找到主机</p><p>port（端口号）找到程序<br>65535个</p><font size="3"><h3 id="一-OSI七层模型-amp-TCP-IP四层模型"><a href="#一-OSI七层模型-amp-TCP-IP四层模型" class="headerlink" title="一. OSI七层模型 &amp; TCP/IP四层模型"></a>一. OSI七层模型 &amp; TCP/IP四层模型</h3><p>​    五层模型 【作用】<br>​    1. 应用层 ： 应用进程间【通信数据】的处理<br>​        2. 传输层 ： 实现【两台主机】间【数据传输】<br>​        3. 网络层 ： 两台主机通信，会经过多段【数据链路】。网络层作用 【选择】合适的路由和交换节点<br>​        4. 数据链路层 ： 确保【一段链路】上的数据传输<br>​        5. 物理层 ： 实现 【两个节点间】【比特流】的【透明传输】</p><hr><h3 id="二-应用层-amp-传输层-amp-网络层-常见协议-1710"><a href="#二-应用层-amp-传输层-amp-网络层-常见协议-1710" class="headerlink" title="二. 应用层 &amp; 传输层 &amp; 网络层 常见协议 1710"></a>二. 应用层 &amp; 传输层 &amp; 网络层 常见协议 1710</h3><h5 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h5><p>​        DNS ： 实现 域名–&gt;IP地址<br>​            (注意：多个主机可以映射成一个IP地址，一台主机 映射唯一MAC地址)<br>​        HTTP ： 实现 客户端 向服务端请求资源，服务端向客户端发送 资源数据(html css js)<br>​        FTP： 文件传输协议<br>​        STMP： 邮件传输协议<br>​        SSL： 加密套接字协议<br>​        </p><h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><p>​        TCP： </p><ol><li><p>【区别】：面向连接、可靠的数据传输，一对一全双工</p></li><li><p>【应用场景】：应用于【文件传输、重要状态更新】</p></li><li><p>【基于TCP的协议】：HTTP、FTP、SMTP 协议基于TCP。 【文件传输、邮件发送，要求可靠性】</p></li></ol><pre><code>     UDP：      1. 【区别】：不面向连接、不可靠的数据传输，一对多     2. 【应用场景】： 应用于【视频传输、实时通信】     3. 【基于UDP的协议】： DNS协议  (数据量小，调用频繁。建立连接开销过大)</code></pre><h5 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h5><p>ARP ： 实现 IP地址–&gt;Mac地址<br>          IP：【主机间通信】  经过多段数据链路，<br>         IP协议 = 【路由+交换节点】的选择<br>         IP协议 = 【无连接、不可靠】数据传输</p><hr><h3 id="三-TCP-三次握手"><a href="#三-TCP-三次握手" class="headerlink" title="三.   TCP 三次握手"></a>三.   TCP 三次握手</h3><p>【==三次握手目的==】： 双方确认 自己和对方的 【<strong>发送与接受正常</strong>】</p><h5 id="！！3-1-为什么三次握手"><a href="#！！3-1-为什么三次握手" class="headerlink" title="！！3.1. 为什么三次握手"></a>！！3.1. 为什么三次握手</h5><p>ACK 确认位<br>SYN 同步位<br>seq 序号： 自己本次数据的开始序号<br>ack 确认号 : 对方下次数据的开始序号</p><p>(1) 客户端–SYN，seq=x –&gt;服务端<br>    服务端确认 客户端发送和服务端接受 正常<br>(2) 服务端–ACK SYN seq=y ack =x+1 –&gt; 客户端<br>    客户端确认  客户端发送和接受 服务端发送和接受 正常<br>    【SYN=1的原因】 ： 服务端告诉客户端 我接收到的信息确实是你发送的<br>(3) 客户端–ACK seq=x+1 ack=y+1–&gt;服务端<br>    服务端确认 客户端接受 和 服务端发送 正常<br>    第三次握手 ，客户端可向 服务端传输信息<br>    【ACK=1的原因】 客户端告诉服务端 ， 我接受到的信息确实是你发送的<br>三次握手 确认双方 接受和发送功能正常，缺一不可</p><h5 id="3-2-缺少第三次握手"><a href="#3-2-缺少第三次握手" class="headerlink" title="3.2 缺少第三次握手"></a>3.2 缺少第三次握手</h5><p>第一次握手时，客户端 发送SYN信息滞留，超时重传。滞留信息 和   超时重传信息最终都成功发送，则存在两次连接建立，浪费资源。</p><hr><h3 id="四-TCP-四次挥手-1853"><a href="#四-TCP-四次挥手-1853" class="headerlink" title="四. TCP 四次挥手 1853"></a>四. TCP 四次挥手 1853</h3><h5 id="！！4-1-四次挥手过程"><a href="#！！4-1-四次挥手过程" class="headerlink" title="！！4.1 四次挥手过程"></a>！！4.1 四次挥手过程</h5><p>​    第一次挥手 ： 客户端–&gt;服务端发送断开请求。请求 = {FIN=1,seq=x}<br>​    第二次挥手 ： 服务端–&gt;客户端发送响应。响应 = {ACK=1,seq=y,ack=x+1}<br>​<br>​    期间存在 服务端–&gt;客户端 发送数据<br>​<br>​    第三次挥手 ： 服务端—&gt;客户端发送断开请求。 请求 = {FIN=1，seq=z}<br>​    第四次挥手 ： 客户端—&gt;服务端发送响应 。 响应 = {ACK=1,ack=z+1,}<br>​<br>​    至此 连接关闭</p><h5 id="！！4-2-第四次挥手后-【客户端-time-wait】，等待2MSL-1933"><a href="#！！4-2-第四次挥手后-【客户端-time-wait】，等待2MSL-1933" class="headerlink" title="！！4.2 第四次挥手后 【客户端= time wait】，等待2MSL 1933"></a>！！4.2 第四次挥手后 【客户端= time wait】，等待2MSL 1933</h5><p>第四次挥手的【报文段】丢失，则服务端【超时重传】第三次挥手【报文段】。<br>若 客户端未等待2MSL直接关闭，则无法接受重传【报文段】，关闭失败。</p><h5 id="4-3-CLOSE-WAIT-TIME-WAIT"><a href="#4-3-CLOSE-WAIT-TIME-WAIT" class="headerlink" title="4.3 CLOSE-WAIT TIME-WAIT"></a>4.3 CLOSE-WAIT TIME-WAIT</h5><ol><li>CLOSED-WAIT ：   服务端 【被动接受】断开连接请求</li><li>TIME-WAIT : 发送完最后一次ACK报文段后，进入TIME-WAIT，等待2MSL.防止最后ACK报文段丢失。</li></ol><h5 id="4-4-TIME-WAIT状态过多"><a href="#4-4-TIME-WAIT状态过多" class="headerlink" title="4.4 TIME-WAIT状态过多"></a>4.4 <a href="https://www.cnblogs.com/dadonggg/p/8778318.html">TIME-WAIT状态过多</a></h5><p>TIME-WAIT状态占用端口。<br>短链接 = {处理业务+传输数据} &lt; TIME-wait的时间 的连接</p><p>【高并发短连接】服务器【主动】申请关闭连接，造成TIME-WAIT过多。</p><p>​    </p><hr><h3 id="五-TCP可靠性"><a href="#五-TCP可靠性" class="headerlink" title="五.TCP可靠性"></a>五.TCP可靠性</h3><ol><li><p>校验和： 确保端到端数据可靠传输，TCP首部含有校验和字段，</p></li><li><p>【ARQ】自动重传请求 :  存在 【等待停止】 和 【GO_BACK_N】 两种ARQ </p></li><li><p>【流量控制】：<br> (1) 【目的】：  防止【接收端】的接受能力不足<br> (2) 接收端返回【确认报文】中含【接收窗口】大小</p></li><li><p>【拥塞控制】:<br> (1) 【目的】：  防止【全局网络 】如【路由器||链路】过载<br> (2) 【网络】拥塞情况决定的【拥塞窗口】大小。<br> (3) TCP拥塞控制采用四种算法, </p><p> ​    1) 慢开始： 拥塞窗口大小cwbd &lt; 慢开始阈值， 每经过一轮传播，cwnd加倍</p><p> ​    2)拥塞避免、 ： 拥塞窗口大小cwbd &gt; 慢开始阈值, 每经过一轮传播 拥塞窗口+1</p><p> ​    3)快重传 :<br> ​        当【接收端】接收到【顺序错误】的报文段后，向【发送端】发送【重复】ACK报文。<br> ​        此时 发送端是根据【接收重复ACK报文】判断传输失败，而不是根据【超时】判断发送失败。避免【超时等待】时，发送端空等。<br> ​    4)快恢复<br> ​        【慢开始阈值】 = 【初始拥塞窗口】 = 【旧拥塞窗口的一半】<br> 【发送窗口】 = Math.min(接收窗口、拥塞窗口);</p><hr></li></ol><h3 id="六-输入URL显示主页-1149-1249"><a href="#六-输入URL显示主页-1149-1249" class="headerlink" title="六. 输入URL显示主页 1149 - 1249"></a>六. 输入URL显示主页 1149 - 1249</h3><ol><li><p>DNS 解析域名</p></li><li><p>建立TCP连接 ： 三次握手</p></li><li><p>创建http请求报文，并通过【SSL加密】。最后发送http请求<br> 请求报文 = {</p><ul><li><p>请求行 = {请求方法 + URL + http版本} </p></li><li><p>请求首部 = {</p><pre><code>  Connnection = keep-alive ，  Accept = 客户端接收的数据类型，  content -length = 内容长度</code></pre><p>   }</p></li><li><p>请求实体 = { 如 【请求方法=post||put】，则请求实体存储传输的数据}<br>}</p><p>请求经过【负载均衡+重定向】</p></li></ul><ol start="4"><li><p>服务端接收解析http请求，并返回http响应。<br>响应报文 = {</p><ul><li><p>响应行 = { 协议版本 + 状态码 }</p></li><li><p>响应首部 = {<br> content-legnth<br> content-type = html<br> }    </p></li><li><p>响应实体 = { 请求所需的资源 如 html css js}<br> }</p><ol start="5"><li><p>浏览器解析http响应，并渲染页面</p></li><li><p>断开TCP连接 ： 四次挥手</p></li></ol></li></ul></li></ol></li></ol><hr><h3 id="七-HTTPS-1500"><a href="#七-HTTPS-1500" class="headerlink" title="七. HTTPS  1500"></a>七. HTTPS  1500</h3><p>(1)    【对称加密】： 密钥只有一个，加密解密使用同个密码。【速度快】<br>            【优点】： 速度快<br>            【缺点】 ： 无法确保【消息来源】，存在自己发自己的情况</p><p>(2)    【非对称加密】： 密钥分 公钥、私钥(本人保管)。<br>            (公钥加密内容 使用私钥解密，私钥加密内容，使用公钥解密)。<br>            【举例】： A 发送邮件给B ， 若邮件使用A的私钥加密，则确保(确保邮件来源)。 若邮件使用B的公钥加密，则确保邮件去处。<br>            【优点】： 确保【消息来源】 || 【消息去处】 【二者按需取一】<br>            【缺点】： 速度慢<br>(3)     【数字签名】：<br>            数字签名 = 对消息的hash值使用私钥加密。<br>            数字签名添加在消息尾部<br>            【优点】：确保 【消息来源】 和 【消息未被修改】。<br>            【缺点】：C修改B电脑中的A公钥，C冒充A发送数据给B，B无法察觉。<br>(4)     【数字证书】：<br>            数字证书 = 将A的公钥交由第三方CA(Certificate Authority)的私钥加密<br>            数字证书 添加在 消息尾部。避免B电脑中A公钥被替换。</p><p>(1) HTTP 默认端口 = 80<br>    HTTP协议 运行在TCP之上，http报文是明文。<br>    【http安全缺陷】 = {<br>            (1) 无法验证服务器身份<br>            (2) 无法确保数据完整性<br>            (3) 无法确保数据未被窃听<br>        }<br>(2) HTTPS 默认端口 = 443<br>    HTTPS = HTTP报文 + SSL协议(加密http报文)<br>    【http报文】 采用【对称加密】，【对称加密的密钥】采用【服务端数字证书】进行【非对称加密】<br>    接收方</p><p> 非对称加密 采用 幂模运算，在解密过程中私钥很大，导致幂运算很慢</p><h5 id="https-加密过程"><a href="#https-加密过程" class="headerlink" title="https 加密过程"></a><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">https 加密过程</a></h5><hr><h3 id="八-HTTP-长短连接-1718"><a href="#八-HTTP-长短连接-1718" class="headerlink" title="八. HTTP 长短连接 1718"></a>八. HTTP 长短连接 1718</h3><p>​    Http短链接 ： 每次客户端发送请求都会重新建立连接。<br>​    Http长连接 ： 服务器响应报文中，其响应首部 connection=keep-alive，表明该链接是长连接，一段时间内不断开。客户端再次发送请求时通过该链接。</p><hr><h3 id="！！九-Cookie-和-Session的区别"><a href="#！！九-Cookie-和-Session的区别" class="headerlink" title="！！九. Cookie 和 Session的区别"></a>！！九. Cookie 和 Session的区别</h3><p>HTTP协议是无状态协议。不保存【用户状态】。</p><p>   (1) Session作用：实现【服务端】存储【用户状态】<br>            每个用户绑定一个SessionID，请求中url或者cookie拿到sessionid<br>            Session存储在服务器||数据库中，超过一段时间会销毁。<br>            常用于 购物车场景。明确购物操作是哪一个用户进行的。</p><p>Cookie作用 ：实现【客户端】存储【用户状态】<br>        有4KB的大小限制<br>        当请求发送给同个domain中服务器，则都会携带cookie<br>        可以禁用cookie<br>        常用于下次访问网站时自动登录</p><hr><h3 id="十-URI-和URL"><a href="#十-URI-和URL" class="headerlink" title="十. URI 和URL"></a>十. URI 和URL</h3><p>​    URI : 统一资源标识符，唯一标识一个资源<br>​    URL : 统一资源定位器，定位资源所在位置</p><hr><h3 id="！十一-HTTP1-0-和-HTTP1-1"><a href="#！十一-HTTP1-0-和-HTTP1-1" class="headerlink" title="！十一. HTTP1.0 和 HTTP1.1"></a>！十一. HTTP1.0 和 HTTP1.1</h3><pre><code>1. HTTP1.0 默认使用短链接 ， HTTP1.1默认使用长连接     </code></pre><ol start="2"><li><p>http1.0 存在【带宽浪费】：<br>   例如<br>   客户端仅需要某资源对象的一部分，<br>   但在http1.0中只能请求整个资源。<br>   http1.1中【允许请求资源的某个部分】，响应码206。</p></li><li><p>【错误状态响应码不同】：<br>   http1.1中增加【错误状态】响应码，<br>   如 409(confilct)请求资源和资源当前状态冲突 410(GONE) 请求资源永久删除 </p></li><li><p>【缓存处理】<br>   http1.1 在报文首部中 引入If-unModitfied-Since If-match等缓存头</p></li><li><h6 id="【host头】："><a href="#【host头】：" class="headerlink" title="【host头】："></a>【host头】：</h6><p>   ttp1.0认为一台主机匹配一个IP地址，因此 request中的URL不带有hostname<br>   虚拟机技术发展， 一台物理主机可以创建多台虚拟主机，<br>   http1.1通过hostname指定虚拟机，http1.1不指定hostname，则会报错400 请求错误</p></li></ol><h4 id="HTTP1-1-和-http-2-0-区别"><a href="#HTTP1-1-和-http-2-0-区别" class="headerlink" title="HTTP1.1 和 http 2.0 区别"></a>HTTP1.1 和 http 2.0 区别</h4><ol><li>HTTP/2采用二进制格式(传统二进制格式 健壮性考虑因素很多)</li><li>多路复用 (共享连接) ：<br> HTTP1.X采用keep alive来解决复用TCP的问题，但是仍存在请求阻塞问题<br> HTTP1.x需要每条请求顺序发送,服务端才能判断接收到的数据属于哪条请求<br> HTTP/2 每个请求以stream的方式传输，每个stream有唯一标识  </li><li>header ：<br> 通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</li></ol><p>   HAPCK</p><p>服务器推送：<br>浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器</p><p>​    </p><hr><h3 id="十二-get和post的区别"><a href="#十二-get和post的区别" class="headerlink" title="十二. get和post的区别"></a>十二. get和post的区别</h3><ol><li>【参数传递】<br> GET参数通过URL传递<br> POST数据通过 http请求的请求实体传递</li><li>【刷新】<br> GET方法用于获取资源，不改变资源的状态，所以是幂等的<br> POST方法用于创建资源，不幂等<br> 两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI</li><li>【缓存问题】<br> GET在浏览器中缓存，post不缓存</li></ol><hr><h4 id="十三-状态码"><a href="#十三-状态码" class="headerlink" title="十三. 状态码"></a>十三. 状态码</h4><p>​    1XX请求成功，正在处理<br>​    2XX请求成功，已经处理<br>​        200 - 请求成功<br>​        206 - 请求部分成功<br>​    3XX 重定向<br>​    301永久重定向<br>​    302临时重定向<br>​<br>​    4XX<br>​    400 请求语法错误<br>​    403 服务被拒绝<br>​    404页面不存在<br>​<br>​    5XX<br>​    500服务器内部错误（报错了）<br>​    502 服务不可用</p><h4 id="十四-正向代理和-反向代理"><a href="#十四-正向代理和-反向代理" class="headerlink" title="十四. 正向代理和 反向代理"></a>十四. 正向代理和 反向代理</h4><p>正向代理隐藏真实客户端，<br>    1. 做【缓存】，加速访问资源<br>        2. 对客户端【授权】<br>        3. 客户端访问记录</p><p>反向代理隐藏真实服务端，<br>    1. 实现负载均衡<br>        2. 避免网络攻击</p></font>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计网学习&quot;&gt;&lt;a href=&quot;#计网学习&quot; class=&quot;headerlink&quot; title=&quot;计网学习&quot;&gt;&lt;/a&gt;计网学习&lt;/h1&gt;&lt;h2 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;br&gt;面向连接的可靠的传输&lt;/p&gt;
&lt;p&gt;确认ACK（确认号是否有效，一般置为1）：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效&lt;/p&gt;
&lt;p&gt;同步SYN（请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1）：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。&lt;/p&gt;
&lt;p&gt;终止FIN（希望断开连接）：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础编程知识学习" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>并发learning</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/02/18/%E5%B9%B6%E5%8F%91learning-1/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/02/18/%E5%B9%B6%E5%8F%91learning-1/</id>
    <published>2021-02-18T12:00:03.000Z</published>
    <updated>2021-02-20T14:15:14.513Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-进程process和线程thread的关系"><a href="#一-进程process和线程thread的关系" class="headerlink" title="一. 进程process和线程thread的关系"></a>一. 进程process和线程thread的关系</h4><h5 id="两者的定义"><a href="#两者的定义" class="headerlink" title="两者的定义"></a><strong>两者的定义</strong></h5><p>进程(process)是程序运行的基本单位。一个进程可以有多个线程。进程是及程序的一次执行过程，是正在运行的程序的抽象，代表了运行的CPU。系统资源（内存，文件等）都已进程为单位分配。操作系统为每个进程都分配了独立的地址空间，同时通过“调度”把控制权交给了进程。</p><p>但是进程存在问题：</p><ol><li>进程切换的代价和开销大</li><li>在一个进程内需要并行执行多个程序与实现不同功能</li><li>有时性能低</li></ol><p>线程(thread)是进程划分成更小的运行单位。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。多个线程【共享】进程的【堆和方法】区资源，但每个线程【独占】一个【程序计数器、虚拟机栈、本地方法栈】。</p><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h5><ol><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多</li></ol><a id="more"></a><hr><h4 id="二-如何避免死锁"><a href="#二-如何避免死锁" class="headerlink" title="二. 如何避免死锁"></a>二. 如何避免死锁</h4><h5 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a><strong>什么是死锁？</strong></h5><p>两个或两个以上的线程在执行过程中，由于竞争资源而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。简化一点说就是：<u>一组相互竞争资源的线程因为互相等待，导致“永久”阻塞的现象。</u></p><h5 id="死锁的【四个必要条件】"><a href="#死锁的【四个必要条件】" class="headerlink" title="死锁的【四个必要条件】"></a><strong>死锁的【四个必要条件】</strong></h5><ul><li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li><li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li><li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li><li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ul><p> <strong>避免【线程死锁】</strong><br>       1. 加锁顺序<br>       2. 加锁时限<br>       3. 死锁检测</p><p><strong>例子</strong>：</p><hr><h4 id="三-一些基础问题"><a href="#三-一些基础问题" class="headerlink" title="三. 一些基础问题"></a>三. 一些基础问题</h4><h5 id="3-1-sleep-和-wait的区别"><a href="#3-1-sleep-和-wait的区别" class="headerlink" title="3.1 sleep 和 wait的区别"></a>3.1 sleep 和 wait的区别</h5><ol><li>【是否释放锁】：sleep 没有释放锁，wait释放锁。<br> 因此 wait多用线程交互，sleep只是暂停线程执行</li><li>【是否自动苏醒】：<br> 线程调用sleep()后，会自动苏醒。<br> 线程调用wait() ，若wait()无参，需要等待其他线程调 【同一对象】的notify() notifyAll()唤醒.若wait()方法有timeout参数,则会超时后苏醒。    </li></ol><h5 id="3-2-为什么调用start执行run-，而不是直接调用run"><a href="#3-2-为什么调用start执行run-，而不是直接调用run" class="headerlink" title="3.2 为什么调用start执行run()，而不是直接调用run()"></a>3.2 为什么调用start执行run()，而不是直接调用run()</h5><p>直接调用run()方法： 只是在main()线程中将run方法作为普通方法调用，还是在main线程中执行。这并不是多线程<br>调用start()方法 ： 启动一个线程 &amp; 使该线程进入就绪状态，当该线程分配到时间片后开始运行。</p><hr><h4 id="四-Synchronized-相关问题"><a href="#四-Synchronized-相关问题" class="headerlink" title="四. Synchronized 相关问题"></a>四. Synchronized 相关问题</h4><h5 id="4-1-sychronized-使用方式"><a href="#4-1-sychronized-使用方式" class="headerlink" title="4.1 sychronized 使用方式"></a>4.1 sychronized 使用方式</h5><p>Synchronized 修饰对象 = {1. 代码块  2. 方法}</p><ol><li>Synchronized 修饰 静态方法 ||  Sychronized(Class)修饰代码块 = {<br> Class 类上锁<br>}</li><li>Synchronized 修饰 实例方法 {<br> 该类的某个对象实例上锁<br>}</li></ol><h5 id="4-2-单例模式-【双重校验锁】-实现对象单例"><a href="#4-2-单例模式-【双重校验锁】-实现对象单例" class="headerlink" title="4.2 单例模式 =  【双重校验锁】 实现对象单例"></a>4.2 单例模式 =  【双重校验锁】 实现对象单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class Singleton&#123;</span><br><span class="line">    <span class="comment">// 为什么 volatile修饰</span></span><br><span class="line">    ---</span><br><span class="line">    </span><br><span class="line">    JVM指令重排 ，为对象分配内存空间，并且uniqueInstance指向该内存地址，但是对象并未初始化</span><br><span class="line">    线程T2调用get方法，在外层校验中发现uniqueInstance！=<span class="keyword">null</span>,则直接返回。【但此时uniqueInstance未被初始化】</span><br><span class="line">    </span><br><span class="line">    ---</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 私有构造器     </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance==<span class="keyword">null</span>)&#123; <span class="comment">// 检测单例是否已经创建</span></span><br><span class="line">            Synchronized(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance==<span class="keyword">null</span>)&#123; <span class="comment">// 检测其他线程是否先获取锁创建了单例对象</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-JDK1-6后-Synchronized的底层优化-1041"><a href="#4-3-JDK1-6后-Synchronized的底层优化-1041" class="headerlink" title="4.3 JDK1.6后 Synchronized的底层优化 1041"></a>4.3 JDK1.6后 Synchronized的底层优化 1041</h5><p>​    四种锁状态 ： 无锁 –&gt; 偏向锁 –&gt; 轻量级锁 —&gt;重量级锁<br>​    锁随着【竞争程度】上升，逐渐升级。但不可降级。</p><pre><code>1. 【初次执行Synchronized代码块】，锁对象变为【偏向锁】    (通过CAS操作修改对象头中【锁标志位】和【持锁线程ID】)。    (偏向锁意为偏向于第一个获取它的线程)。执行完同步块后，线程不主动释放偏向锁。    当执行下一个同步块时，检测该当前想要获取锁的线程是否就是持有锁的线程。    如果是，则正常执行。【线程没有释放锁，因此也不用重新加锁】   2. 【一旦出现锁竞争】，偏向锁升级为【轻量级锁】。    如果锁标志位=释放，则线程通过【CAS操作】修改锁标志位，并获取锁。    如果锁标志位=锁定，则线程通过【自旋】等待锁的释放。    自旋：一个线程获取锁，其他线程通过忙循环等待线程释放锁。    轻量级锁本质 = 【忙等开销 换取 用户态切换到核心态的开销】   3. 【忙等是有限度】，当某个线程自旋次数达到最大自选次数。    该线程通过CAS操作修改对象头的锁标志位，表明轻量级锁升级为【重量级锁】    一个线程持有锁时，其他请求线程只能阻塞等待。</code></pre><h5 id="4-4-synchronized-底层"><a href="#4-4-synchronized-底层" class="headerlink" title="4.4 synchronized 底层"></a>4.4 synchronized 底层</h5><p>Sychronized 修饰 代码块 || 方法<br>    1.修饰代码块时<br>        通过 【monitorenter 和 monitorExit 两条指令】，分别指定同步代码块的 开始位置和结束位置。<br>        线程获取锁 = 获取位于对象头的monitor的持有权<br>        获取到锁，则计数器++。 执行到monitorExit，则计数器–</p><pre><code>2.修饰方法     JVM通过 ACC_SYNCHRONIZED 辨别方法为同步方法 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【面试口头】</span><br><span class="line">    Sychronized 是【JVM】层面的关键字。它是通过 【字节码指令】实现的。</span><br><span class="line">       (1) Sychronized 修饰 【代码块】时，montior-enter monitor-exit两个字节码指令表明 同步块的开始和结束位置。</span><br><span class="line">       (2) Sychronized 修饰 【方法】时，JVM中通过ACC_SYCHRONIZED 标志同步方法 </span><br></pre></td></tr></table></figure><h5 id="4-5-ReentrantLock-和-Sychronized-区别"><a href="#4-5-ReentrantLock-和-Sychronized-区别" class="headerlink" title="4.5  ReentrantLock 和 Sychronized 区别"></a>4.5  ReentrantLock 和 Sychronized 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.  两者都是【可重入锁】 : </span><br><span class="line">    获得某一对象锁时，若自己未释放，也可重复再次获得该对象的锁 。 锁计数器++ </span><br><span class="line">    </span><br><span class="line">2. Sychronized 依赖JVM实现，而ReentrantLock 依赖API实现(JDK层面)</span><br><span class="line">    ReentrantLock 调用 lock() unlock() try&#x2F;finally语句 实现同步块，可以直接查看源代码</span><br><span class="line">    Sychronized 在JVM层面，通过字节码指令 monitorEnter monitorExit指定同步块的开始和结束位置 </span><br><span class="line">    </span><br><span class="line">3. ReentrantLock 实现高级功能</span><br><span class="line">    (1) ReentrantLock实现等待可中断 ： </span><br><span class="line">        通过调用 lockInterruptibly() 中断等待锁的线程</span><br><span class="line">    (2) ReentrantLock可实现公平锁，而Sychronized仅实现非公平锁：</span><br><span class="line">        公平锁 &#x3D; 先等待的线程，先获得锁</span><br><span class="line">    (3) 等待&#x2F;通知机制 不同：</span><br><span class="line">        Sychronized 通过 notiy() notifyAll() wait() 实现等待&#x2F;通知机制</span><br><span class="line">        ReentrantLock 通过 Condition对象实现。</span><br><span class="line">            一个lock可创建多个Condition对象，一个Condition对象可注册多个线程。</span><br><span class="line">            Condition 对象调用signal ||signalAll() </span><br><span class="line">                唤醒线程所在范围 &#x3D;  注册的线程，</span><br><span class="line">            而Sychronized 调用 notify() || notifyAll() </span><br><span class="line">                唤醒线程 &#x3D; JVM选择的</span><br><span class="line">            因此 ReentrantLock的等待通知机制更加灵活</span><br><span class="line">    </span><br><span class="line">        </span><br></pre></td></tr></table></figure><hr><h4 id="五-volatile"><a href="#五-volatile" class="headerlink" title="五. volatile"></a>五. volatile</h4><h5 id="5-1-volatile-作用"><a href="#5-1-volatile-作用" class="headerlink" title="5.1 volatile 作用"></a>5.1 volatile 作用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 防止指令重排</span><br><span class="line">2. 保证变量的可见性</span><br><span class="line">    当前Java内存模型，不是从主存读取变量，而是将变量保存在本地内存(寄存器)。</span><br><span class="line">    可能存在 一个线程修改【主存】中的变量值，而另一个线程仍使用【本地内存】中的变量拷贝值，</span><br><span class="line">    造成【数据】不一致。</span><br><span class="line">    变量声明为volatile，即告知JVM该变量不稳定。每次要在主存中读取值。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="5-2-Synchronized-和-volatile-的区别"><a href="#5-2-Synchronized-和-volatile-的区别" class="headerlink" title="5.2 Synchronized 和 volatile 的区别"></a>5.2 Synchronized 和 volatile 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 【是否阻塞】</span><br><span class="line">    volatile 不会造成阻塞，Synchronized会造成阻塞</span><br><span class="line">2. 【作用范围不同】</span><br><span class="line">    volatile 只能修饰变量， Synchronized 修饰 代码块和 方法 </span><br><span class="line">3. 【作用不同】</span><br><span class="line">    volatile 主要用于保证变量在多个线程之间的可见性，而Synchronized则是保证临界资源在多个线程之间的同步性</span><br><span class="line">    volatile 仅保证变量的可见性，而不保证原子性。Synchronized两者都能保证</span><br><span class="line">4. 【效率】</span><br><span class="line">    volatile 是 线程同步的轻量级实现，效率高于Sychronized</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="五-ThreadLocal"><a href="#五-ThreadLocal" class="headerlink" title="五. ThreadLocal"></a>五. ThreadLocal</h4><p>作用 ： 和每个线程绑定专属的本地变量</p><h5 id="！5-1-ThreadLocal-底层原理"><a href="#！5-1-ThreadLocal-底层原理" class="headerlink" title="！5.1 ThreadLocal 底层原理"></a>！5.1 ThreadLocal 底层原理</h5><p>每个Thread对象中具备threadLocalMap ，而threadLocalMap中存储 key=threadLocal的键值对。<br>ThreadLocal.get() threadLocal.set();</p><h5 id="5-2-软引用-amp-弱引用"><a href="#5-2-软引用-amp-弱引用" class="headerlink" title="5.2 软引用 &amp; 弱引用"></a>5.2 软引用 &amp; 弱引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚引用-&gt; 弱引用 -&gt; 软引用 -&gt; 强引用</span><br><span class="line">弱引用被GC线程发现后，不论内存空间是否不足，都立刻回收</span><br><span class="line">软引用被GC线程发现后，如果内存空间不足，则回收</span><br></pre></td></tr></table></figure><hr><h4 id="！！六-线程池-1057"><a href="#！！六-线程池-1057" class="headerlink" title="！！六. 线程池 1057"></a>！！六. 线程池 1057</h4><p>作用 ： 减少 创建和销毁线程的开销，任务无需等待线程创建可立即执行。</p><h5 id="6-1-callable-和-runnable-的区别"><a href="#6-1-callable-和-runnable-的区别" class="headerlink" title="6.1 callable 和 runnable 的区别"></a>6.1 callable 和 runnable 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable 可返回值||抛出异常，runnable不行</span><br></pre></td></tr></table></figure><h5 id="6-2-submit-和-execute-区别"><a href="#6-2-submit-和-execute-区别" class="headerlink" title="6.2 submit 和 execute 区别"></a>6.2 submit 和 execute 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute提交【无返回值】的任务，无法根据返回值判断任务是否成功执行</span><br><span class="line">submit提交【有返回值】的任务，根据返回值判断任务是否成功执行</span><br></pre></td></tr></table></figure><h5 id="6-3-【如何】创建线程池-1344"><a href="#6-3-【如何】创建线程池-1344" class="headerlink" title="6.3  【如何】创建线程池 1344"></a>6.3  【如何】创建线程池 1344</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">方法1 ： 通过构造器 </span><br><span class="line">ThreadPoolExecutor();</span><br><span class="line">！！ 【构造器参数】</span><br><span class="line"></span><br><span class="line">    1. int corePoolSize：</span><br><span class="line">        任务数 &lt; 核心池大小 ，</span><br><span class="line">        则将任务交给空闲线程 || 创建新线程 处理  </span><br><span class="line">    2. int maximunPoolSize：</span><br><span class="line">        等待队列已满 &amp; 核心池大小&lt;任务数&lt; 最大线程数量，</span><br><span class="line">        则创建临时线程</span><br><span class="line">    3. long keepAliveTime,TimeUtil：</span><br><span class="line">        线程空闲时间 &gt; 指定时间后，则线程销毁</span><br><span class="line">    4. BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">        任务数&gt;核心池大小 &amp; 请求队列未满 ，</span><br><span class="line">        则任务加入请求队列</span><br><span class="line">        </span><br><span class="line">    5. ThreadFactory</span><br><span class="line">        负责创建线程</span><br><span class="line">    6. handler 制定拒绝策略</span><br><span class="line">方法2： 通过【工具类Executors】 创建线程池。 线程池类型如下 </span><br><span class="line">    1. FixedThreadPool ： 线程数量固定</span><br><span class="line">    2. SingleThreadExecutor : 线程数量&#x3D;1 ，多余任务提交给线程池则进入等待队列</span><br><span class="line">        如果创建这两类线程池，则其 请求队列长度&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        可能堆积大量请求而导致OOM</span><br><span class="line">        </span><br><span class="line">    3. CachedThreadPool ： 线程数量不固定，优先复用空闲线程</span><br><span class="line">        该类线程池，允许创建的线程数量&#x3D;Integer.MAX_VALUE,</span><br><span class="line">        可能创建过多线程，导致OOM</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="6-4-线程池拒绝策略"><a href="#6-4-线程池拒绝策略" class="headerlink" title="6.4 线程池拒绝策略"></a>6.4 线程池拒绝策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. abort : 默认使用的拒绝策略， 拒绝执行任务，抛出异常</span><br><span class="line">2. CallerRunPolicy ： 调用 当前线程池所在线程执行任务</span><br><span class="line">3. discard ： 直接抛弃任务，不做任何处理</span><br><span class="line">4. discardOldest ： 抛弃 请求队列中最早的任务</span><br></pre></td></tr></table></figure><h5 id="6-5-Executor创建线程池的【弊端】"><a href="#6-5-Executor创建线程池的【弊端】" class="headerlink" title="6.5 Executor创建线程池的【弊端】"></a>6.5 Executor创建线程池的【弊端】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FixedThreadPool 、SingleThreadExecutor 中等待队列长度设置为Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool 允许最大线程数设置为 Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">这两者都可能造成 OOM的问题</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="七-AQS-1430"><a href="#七-AQS-1430" class="headerlink" title="七. AQS 1430"></a>七. AQS 1430</h4><p><img src="https://note.youdao.com/yws/res/43414/400F2FB130F9470BAD70079722D25F33" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">一. AQS 是构建同步器的【框架】 </span><br><span class="line">        【核心思想】 ： 线程请求资源 </span><br><span class="line">        情况1 ： 资源空闲</span><br><span class="line">            则 请求线程设置为工作线程，资源上锁</span><br><span class="line">        情况2 ： 资源被占用</span><br><span class="line">            则 请求线程阻塞，加入CLH队列。等待资源空闲时竞争资源</span><br><span class="line">    </span><br><span class="line">二. AQS 定义两种 资源共享模式</span><br><span class="line">    1. 独占锁 Exclusive  ： 锁只能被一个线程占有</span><br><span class="line">        例如 ： ReentrantLock 又分为 公平锁和非公平锁</span><br><span class="line">        </span><br><span class="line">    2. 共享锁 shared    ： 多个线程共享锁</span><br><span class="line">        例如 ： CountDownLatch 、Semaphore</span><br><span class="line">        </span><br><span class="line">三. AQS框架 自定义模块</span><br><span class="line">    尝试 获取&#x2F;释放 独占资源</span><br><span class="line">    tryAcquire()</span><br><span class="line">    tryRelease()</span><br><span class="line">    尝试 获取&#x2F;释放共享资源</span><br><span class="line">    tryAcquireShared()</span><br><span class="line">    tryReleaseShared()</span><br><span class="line"></span><br><span class="line">四. AQS 常见组件 </span><br><span class="line">    1. ReentrantLock </span><br><span class="line">        A 线程调用 lock()方法</span><br><span class="line">        若 state&#x3D;0 ，</span><br><span class="line">            则资源空闲 ，state++，且 A线程可重复获取锁 </span><br><span class="line">            </span><br><span class="line">        若 state！&#x3D;0 ， </span><br><span class="line">            则资源被占有，当state&#x3D;0时其他线程才能竞争</span><br><span class="line">    </span><br><span class="line">    2. CountDownLatch </span><br><span class="line">        (1) 构造器初始化 【state &#x3D; N】</span><br><span class="line">            </span><br><span class="line">            当【子线程】调用countDown(),通过 CAS操作state自减1</span><br><span class="line">            </span><br><span class="line">            当state&#x3D;0 时，调用await的线程 恢复正常继续执行</span><br><span class="line">    </span><br><span class="line">    3. CyclicBarrier </span><br><span class="line">        构造方法 state&#x3D;n</span><br><span class="line">         </span><br><span class="line">        每当一个线程调用 await()方法，则CAS操作state自减1</span><br><span class="line">            </span><br><span class="line">        当state&#x3D;0 时 ，所有调用await()的线程恢复</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">         </span><br></pre></td></tr></table></figure><hr><h5 id="AQS源码"><a href="#AQS源码" class="headerlink" title="AQS源码"></a>AQS源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. aquire()</span><br><span class="line"></span><br><span class="line">public void aquire()&#123;   </span><br><span class="line">    if(!tryAcquire()    &#x2F;&#x2F; 尝试获取一次  </span><br><span class="line">        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg)) </span><br><span class="line">            &#x2F;&#x2F; acquireQueued 【作用】： 自旋检测  (tryAcquire()&amp;&amp; node&#x3D;&#x3D;head.next)</span><br><span class="line">            &#x2F;&#x2F; addWaiter【作用】： 添加当前线程node至 队列尾部</span><br><span class="line">            </span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">【问题】： 为何不仅调用 acuqireQueued(addWaiter())</span><br><span class="line">    优先尝试最可能成功的代码， 可减少执行的字节码指令</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八-用户态和核心态-1425"><a href="#八-用户态和核心态-1425" class="headerlink" title="八. 用户态和核心态 1425"></a>八. 用户态和核心态 1425</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指令分为 特权指令和非特权指令</span><br><span class="line">其中 特权指令必须在核心态执行，如 启动IO &#x2F;内存清零 &#x2F;修改程序状态字</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="九-乐观锁和悲观锁-很不错的总结"><a href="#九-乐观锁和悲观锁-很不错的总结" class="headerlink" title="九. 乐观锁和悲观锁 很不错的总结"></a>九. <a href="https://www.zhihu.com/search?type=content&q=%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81">乐观锁和悲观锁</a> 很不错的总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">悲观锁和乐观锁 是锁的两种分类，并非特指某一个锁。</span><br><span class="line">悲观锁【通过阻塞机制】实现，乐观锁通过【回滚重试】实现。</span><br><span class="line"></span><br><span class="line">1. 悲观锁 ：</span><br><span class="line">    【描述】：线程独占临界资源，在线程执行完毕前，其他【请求】线程只能【阻塞】等待</span><br><span class="line">    【适用场景】： 写操作较多，资源竞争激烈。</span><br><span class="line">2. 乐观锁 ：</span><br><span class="line">    【描述】：乐观锁并【未上锁】，【更新前】检测该数据在【读取到更新】这一段时间内是否被其他线程修改。如果被修改，则循环操作直到成功为止。</span><br><span class="line">    【使用场景】: 读操作较多，资源竞争情况较少</span><br><span class="line">3. CAS 是原子性操作，是乐观锁实现的基础：</span><br><span class="line">    （1） 读取值A，在更新为B之前，检测【原值】是否为A</span><br><span class="line">    （2） 如果是，则更新为B</span><br><span class="line">          如果不是，则更新失败。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="十-Atomic原子性"><a href="#十-Atomic原子性" class="headerlink" title="十. Atomic原子性"></a>十. Atomic原子性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过 &#123;</span><br><span class="line">    unsafe CAS操作</span><br><span class="line">    Volitle 修饰属性，保证可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十一-多线程内存模型"><a href="#十一-多线程内存模型" class="headerlink" title="十一. 多线程内存模型"></a>十一. 多线程内存模型</h4>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;一-进程process和线程thread的关系&quot;&gt;&lt;a href=&quot;#一-进程process和线程thread的关系&quot; class=&quot;headerlink&quot; title=&quot;一. 进程process和线程thread的关系&quot;&gt;&lt;/a&gt;一. 进程process和线程thread的关系&lt;/h4&gt;&lt;h5 id=&quot;两者的定义&quot;&gt;&lt;a href=&quot;#两者的定义&quot; class=&quot;headerlink&quot; title=&quot;两者的定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;两者的定义&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;进程(process)是程序运行的基本单位。一个进程可以有多个线程。进程是及程序的一次执行过程，是正在运行的程序的抽象，代表了运行的CPU。系统资源（内存，文件等）都已进程为单位分配。操作系统为每个进程都分配了独立的地址空间，同时通过“调度”把控制权交给了进程。&lt;/p&gt;
&lt;p&gt;但是进程存在问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程切换的代价和开销大&lt;/li&gt;
&lt;li&gt;在一个进程内需要并行执行多个程序与实现不同功能&lt;/li&gt;
&lt;li&gt;有时性能低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;线程(thread)是进程划分成更小的运行单位。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。多个线程【共享】进程的【堆和方法】区资源，但每个线程【独占】一个【程序计数器、虚拟机栈、本地方法栈】。&lt;/p&gt;
&lt;h5 id=&quot;区别：&quot;&gt;&lt;a href=&quot;#区别：&quot; class=&quot;headerlink&quot; title=&quot;区别：&quot;&gt;&lt;/a&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；&lt;/li&gt;
&lt;li&gt;一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线&lt;/li&gt;
&lt;li&gt;进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；&lt;/li&gt;
&lt;li&gt;调度和切换：线程上下文切换比进程上下文切换要快得多&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="基础编程知识学习" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>java学习</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/01/18/java%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/01/18/java%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-18T10:28:47.000Z</published>
    <updated>2021-02-21T08:45:43.232Z</updated>
    
    <content type="html"><![CDATA[<font size="3"><h3 id="一-Java-方法中-仅存在【值传递】"><a href="#一-Java-方法中-仅存在【值传递】" class="headerlink" title="一.Java 方法中 仅存在【值传递】"></a>一.Java 方法中 仅存在【值传递】</h3><p>方法得到所有【参数值的拷贝】，因此，方法不能修改一个基本数据，【对象引用作为参数】，则该参数和对象引用指向同一个对象。</p><hr><h3 id="二-和-equals-区别"><a href="#二-和-equals-区别" class="headerlink" title="二. == 和 equals 区别"></a>二. == 和 equals 区别</h3><h5 id="1"><a href="#1" class="headerlink" title="1. =="></a>1. ==</h5><p> == 判断两个对象的【<strong>地址</strong>】是否相同， 即是否【<strong>同一个对象</strong>】</p><h5 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals"></a>2. equals</h5><p>equals 分两种情况<br>(1) equals 【<strong>没有被类重写</strong>】，则equals方法等价==<br>(2) equals 【<strong>被类重写</strong>】， 则根据重写方法 判断两个对象内容是否相等  </p><a id="more"></a><hr><h3 id="三-为什么重写euqals-方法-必须重写-hashCode"><a href="#三-为什么重写euqals-方法-必须重写-hashCode" class="headerlink" title="三. 为什么重写euqals 方法 必须重写 hashCode()"></a>三. 为什么重写euqals 方法 必须重写 hashCode()</h3><ol><li><p>两个对象 hashCode() 所得hash值相等 ， 但equals()方法不一定返回true  </p></li><li><p>两个对象 equals() 返回true，那么对象调用hashCode()返回的hash值一定相等  </p></li><li><p> 如果 仅重写 equals(),而不重写hashcode(),则存在 equals方法会返回true，而hashcode()方法返回的hash值不相等  </p></li><li><p>HashMap中 两个key 重复  </p></li></ol><p><strong>为什么hash值相同，而两个对象不一定equals</strong></p><ul><li>hashCode() 算法存在碰撞情况</li></ul><hr><h3 id="四-String-和-StringBuffer、StringBuilder-区别"><a href="#四-String-和-StringBuffer、StringBuilder-区别" class="headerlink" title="四. String 和 StringBuffer、StringBuilder 区别"></a>四. String 和 StringBuffer、StringBuilder 区别</h3><ol><li><p>String 【<strong>字符串常量</strong>】 ：</p><p>内部的 char[] 是通过final修饰符修饰，因此String是<strong>不可变对象</strong></p></li><li><p>StringBuffer ： 线程安全 </p></li><li><p>StringBuilder </p><p>StringBuffer 和 StringBuilder 都继承 AbstractStringBuilder</p></li></ol><p>该父类定义了append insert等公共方法<br>StringBuffer 对实现的方法加上同步锁，线程安全<br>StringBuilder 对实现的方法没有上锁，所以线程非安全</p><p>String： 适用操作少量数据<br>StringBuilder ： 适用于 【单线程】操作大量数据<br>StringBuffer ：适用于 【多线程】操作大量数据</p><hr><h3 id="五-反射"><a href="#五-反射" class="headerlink" title="五. 反射"></a>五. 反射</h3><p>反射 ： 是把java类中各个成分 映射成一个个java对象</p><ol><li>获取class对象三种方式 </li></ol><ul><li>object.getClass()    // 通过【对象实例】获取class</li><li>Object.class;        // 通过【类的静态class属性】 获取class </li><li>Class.forName(String className) // 通过 【class名】获取 class</li></ul><ol start="2"><li>运行期间，一个类只能有一个Class对象产生</li><li>反射的应用场景  </li></ol><ul><li>JDBC 连接数据库时，反射加载 【驱动程序】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forNmae(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="comment">// 加载驱动程序</span></span><br></pre></td></tr></table></figure><ul><li>Spring中 IOC容器根据配置文件信息–&gt; 获取类文件信息–&gt;反射创建bean实例 ，并反射调用Set方法设置属性</li></ul><ol start="4"><li><p>反射 优缺点</p><ul><li>优点： 在【运行时】，动态加载类，使代码更灵活</li><li>缺点 ： 反射是一系列解释性操作，通过JVM实现。效率低于Java代码</li></ul></li><li><p>反射定义</p></li></ol><p><strong>反射本质就是根据类class的字节码信息，将类的内部属性方法一一映射成Java对象</strong></p><hr><h3 id="六-接口interface和抽象类abstract-class的区别"><a href="#六-接口interface和抽象类abstract-class的区别" class="headerlink" title="六. 接口interface和抽象类abstract class的区别"></a>六. 接口interface和抽象类abstract class的区别</h3><ol><li>接口是对行为(方法)的抽象，是一种对行为的规范。抽象类是对类的抽象，用来捕捉子类的共同特征，提供设计模板。</li><li>一个类可实现多个接口(implements),一个类只能继承一个抽象类(extend)</li><li>类实现接口，则接口内抽象方法必须全部实现。<br> 类继承抽象类，则抽象类内抽象方法不一定全部实现</li><li>接口内实例变量默认final类型，方法默认public。而抽象类内没有限制。</li></ol><p><strong>什么时候使用抽象类和接口</strong></p><ul><li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用<strong>抽象类</strong>吧。</li><li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li><li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li></ul><p><a href="https://www.cnblogs.com/dolphin0520/p/3811437.html">深入理解Java的接口和抽象类</a></p><hr><h3 id="七-重写override和重载overload的区别"><a href="#七-重写override和重载overload的区别" class="headerlink" title="七. 重写override和重载overload的区别"></a>七. 重写override和重载overload的区别</h3><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png" alt="java多态性的不同表现"></p><p><strong>重写 ：</strong> </p><ol><li><p><strong>发生在子类与父类中</strong></p></li><li><p>相同的方法名</p></li><li><p>相同的参数列表</p></li><li><p>返回值相同 或者 子类方法的返回值是父类方法返回值类型的子类</p></li><li><p>访问修饰符相同 或者 子类方法的修饰符范围 大于 父类</p></li><li><p>抛出的异常相同 或者 子类方法抛出的异常 小于父类。例如：父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</p></li></ol><p>   【方法的外貌没有改变，方法提供的行为改变】</p><p>   【返回值】【抛出异常类型】 都是其父类方法的子类 </p><p>   【访问修饰符】 子类访问权限&gt;=父类访问权限 </p><p><strong>重载 ：</strong> </p><ol><li><strong>发生在同一个类中</strong></li><li>相同的方法名</li><li>参数列表不同</li><li>不看返回值，如果出现了只有返回值不同的“重载”，是错的。</li></ol><p>【参数】 【返回值】 【访问修饰符范围】 都发生改变 </p><p><a href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload)</a></p><hr><h3 id="八-异常体系"><a href="#八-异常体系" class="headerlink" title="八. 异常体系"></a>八. 异常体系</h3><p>所有异常继承公共祖先【throwable类】</p><p>异常分为两大类 ： Exception &amp; Error<br>(1) Error 是【程序无法处理】的错误，大部分是代码在JVM运行时出现问题。</p><p>​    如程序申请内存时，内存资源不足。抛出OOM<br>​    Error发生时，JVM一般会【终止】线程<br>(2) Exception是【程序可以处理】的错误</p><p>​    常见Exception：         </p><ul><li>ArithmeticException 算数异常</li><li>NullPointException 空指针异常</li><li>ArrayIndexOutOfBoundsException 下标越界</li></ul><hr><h3 id="九-深拷贝-amp-浅拷贝"><a href="#九-深拷贝-amp-浅拷贝" class="headerlink" title="九. 深拷贝 &amp; 浅拷贝"></a>九. 深拷贝 &amp; 浅拷贝</h3><p>浅拷贝 ： 对基本数据类型【值传递】，对引用数据类型进行 引用地址拷贝<br>深拷贝 ： 对基本数据类型【值传递】，对引用数据类型，则创建新对象，并复制其内容到新对象中。</p><hr><h3 id="十-泛型"><a href="#十-泛型" class="headerlink" title="十. 泛型"></a>十. 泛型</h3><p><strong>Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常</strong>.</p><p>泛型：<strong>把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型</strong></p><ol><li><p>泛型的作用  </p><p>泛型是 【编译期】的【类型确认】机制。在【编译期】确认【容器】内元素为正确类型。防止ClassCastException</p></li><li><p>泛型擦除<br>编译器在【编译期】，确认类型正确后，擦除【容器的类型信息】。所以在【运行时】，容器不存在【类型信息】。<br>如List<String> 在JVM中运行时 仅为List，不存在<String>信息</String></String></p></li></ol><p><a href="https://segmentfault.com/a/1190000014120746">泛型就是这么简单</a></p><hr><h3 id="十一-final"><a href="#十一-final" class="headerlink" title="十一. final"></a>十一. final</h3><p> final 修饰 变量 、方法 、 类<br>           1. 修饰【变量】：<br>            变量 = 基础数据类型 ， 则变量值不可变<br>            变量 = 引用数据类型， 则引用对象不可变<br>           2. 修饰【类】<br>            类不能被继承<br>           3. 修饰【方法】<br>            方法不能被子类重写</p><hr><h3 id="十二-Java-三大特性-封装-继承-多态"><a href="#十二-Java-三大特性-封装-继承-多态" class="headerlink" title="十二. Java 三大特性: 封装 + 继承 + 多态"></a>十二. Java 三大特性: 封装 + 继承 + 多态</h3><ol><li>封装 </li></ol><p>对象属性【私有化】 ， 提供外界【访问】属性的方法</p><ol start="2"><li>继承</li></ol><ul><li>子类 拥有父类的属性和方法 ， 但是父类privete属性和方法 子类无法调用</li><li>子类可【扩展】，拥有自己的属性和方法</li><li>子类 重写 父类的方法 </li></ul><ol start="3"><li>多态</li></ol><p>对象引用 指向的实例类型未知<br>因此 ，【对象引用的方法调用 】，在【运行时】确定调用的是哪个方法</p><hr><h3 id="十三-Object-方法"><a href="#十三-Object-方法" class="headerlink" title="十三. Object 方法"></a>十三. Object 方法</h3><h5 id="equal-hashcode"><a href="#equal-hashcode" class="headerlink" title="equal hashcode"></a>equal hashcode</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == <span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            Person person= (Person) obj;<span class="comment">// 强转类型</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name.equals(person.getName())&amp;&amp;person.age==age;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h5><p>获得类文件对象</p><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p>深浅拷贝</p><h5 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h5><p>​    用于GC的垃圾回收<br>       1. 实例不可达，GC判断实例是否【重写】finalize方法，未重写则直接回收<br>       2. 否则，将实例加入F-Queue队列，由低优先级线程执行F-Queue中实例的finalize方法<br>       3. finalize方法执行完毕后，【再次】判断实例对象是否可达。可达则复活，否则回收</p><hr><h3 id="十四-静态内部类-和内部类"><a href="#十四-静态内部类-和内部类" class="headerlink" title="十四. 静态内部类 和内部类"></a>十四. 静态内部类 和内部类</h3><ol><li> 静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员</li><li>静态内部类 访问 外部类的【静态】静态成员,<br>  而非静态内部类 访问 外部类的【所有成员】(方法，属性)</li><li>静态内部类【实例创建】 不依赖于外部类的实例，通过类名直接调用构造器<br>非静态内部类【实例创建】，依赖于外部类的实例，通过外部实例调用构造器</li></ol><hr><h3 id="十五-线程池只是销毁了超出核心线程数目的空闲线程而已-没有标记表明线程是否核心"><a href="#十五-线程池只是销毁了超出核心线程数目的空闲线程而已-没有标记表明线程是否核心" class="headerlink" title="十五. 线程池只是销毁了超出核心线程数目的空闲线程而已,没有标记表明线程是否核心"></a>十五. 线程池只是销毁了超出核心线程数目的空闲线程而已,没有标记表明线程是否核心</h3><hr><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="创建模式：-工厂模式-、抽象工厂模式、单例模式"><a href="#创建模式：-工厂模式-、抽象工厂模式、单例模式" class="headerlink" title="创建模式： 工厂模式 、抽象工厂模式、单例模式"></a>创建模式： 工厂模式 、抽象工厂模式、单例模式</h5><ol><li><strong>工厂模式</strong></li></ol><p>意义： 为对象的创建提供接口，隔离具体的创建过程<br>{<br>    1. 扩展性 ： 构造器修改<br>        2. 降低代码量： 创建对象的过程有一定代码量，且在多处使用。<br>}</p><p>简单工厂模式<br>    工厂类(唯一)、抽象产品类(唯一)、具体产品类<br>    每当添加具体产品，则需要在唯一工厂类中添加相应业务逻辑，这不符合开放封闭原则</p><p>适用于： 创建具体产品较少场景</p><p>工厂方法模式<br>    抽象工厂类、具体工厂类、抽象产品、具体产品<br>    抽象工厂类提供创建接口，而其子类(具体工厂)确定要创建的对象<br>    每添加一个具体产品，对应添加一个具体工厂类</p><p>抽象工厂模式<br>    抽象工厂(一组) 、具体工厂、抽象产品、具体产品</p><ol start="2"><li><strong>单例模式</strong></li></ol><p>饿汉式 + 懒汉式</p><ol start="3"><li><strong>结构模式：</strong></li></ol><h5 id="装饰器模式、代理模式"><a href="#装饰器模式、代理模式" class="headerlink" title="装饰器模式、代理模式"></a><a href="https://www.jianshu.com/p/c06a686dae39">装饰器模式、代理模式</a></h5><p>两者内部都持有 原对象属性</p><p>代理：<br>    注重 如何调用源对象某一个功能，<br>        不需要兼顾源对象的其他功能</p><p>装饰：<br>    注重 原对象【功能扩展】。<br>    装饰类实例需要【兼顾】原对象的其他方法。因为扩展后的对象仍是是对象本身。</p><hr></font>]]></content>
    
    
    <summary type="html">&lt;font size=&quot;3&quot;&gt;

&lt;h3 id=&quot;一-Java-方法中-仅存在【值传递】&quot;&gt;&lt;a href=&quot;#一-Java-方法中-仅存在【值传递】&quot; class=&quot;headerlink&quot; title=&quot;一.Java 方法中 仅存在【值传递】&quot;&gt;&lt;/a&gt;一.Java 方法中 仅存在【值传递】&lt;/h3&gt;&lt;p&gt;方法得到所有【参数值的拷贝】，因此，方法不能修改一个基本数据，【对象引用作为参数】，则该参数和对象引用指向同一个对象。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;二-和-equals-区别&quot;&gt;&lt;a href=&quot;#二-和-equals-区别&quot; class=&quot;headerlink&quot; title=&quot;二. == 和 equals 区别&quot;&gt;&lt;/a&gt;二. == 和 equals 区别&lt;/h3&gt;&lt;h5 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1. ==&quot;&gt;&lt;/a&gt;1. ==&lt;/h5&gt;&lt;p&gt; == 判断两个对象的【&lt;strong&gt;地址&lt;/strong&gt;】是否相同， 即是否【&lt;strong&gt;同一个对象&lt;/strong&gt;】&lt;/p&gt;
&lt;h5 id=&quot;2-equals&quot;&gt;&lt;a href=&quot;#2-equals&quot; class=&quot;headerlink&quot; title=&quot;2. equals&quot;&gt;&lt;/a&gt;2. equals&lt;/h5&gt;&lt;p&gt;equals 分两种情况&lt;br&gt;(1) equals 【&lt;strong&gt;没有被类重写&lt;/strong&gt;】，则equals方法等价==&lt;br&gt;(2) equals 【&lt;strong&gt;被类重写&lt;/strong&gt;】， 则根据重写方法 判断两个对象内容是否相等  &lt;/p&gt;&lt;/font&gt;</summary>
    
    
    
    
    <category term="基础编程知识学习" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2021/01/18/SQL%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2021/01/18/SQL%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-18T10:26:41.000Z</published>
    <updated>2021-02-21T10:50:35.717Z</updated>
    
    <content type="html"><![CDATA[<font size="3"><h3 id="一-mysql存储引擎-MyISAM-和-InnoDB的区别"><a href="#一-mysql存储引擎-MyISAM-和-InnoDB的区别" class="headerlink" title="一. mysql存储引擎 = { MyISAM 和 InnoDB的区别}"></a>一. mysql存储引擎 = { MyISAM 和 InnoDB的区别}</h3><ol><li><p>【是否支持行锁】<br>  MyISAM 仅支持表锁， InnoDB支持表锁和行锁</p></li><li><p>【是否支持事务】<br>  MyISAM不支持事务，且不具备【崩溃恢复能力】。<br>  InnoDB 支持事务，提供回滚和崩溃恢复。</p></li><li><p>【是否支持外键】<br>  仅InnoDB支持外键 </p></li><li><p>【是否支持MVCC】<br>  仅InnoDB支持MVCC</p></li><li><p>【应用场景不同】<br>  MyISAM 适用 【Select】频繁，并发少<br>  InnoDB 适用 【Insert Delete Update】频繁，高并发</p><p>  因为<br>  (1) MyISAM 仅缓存索引块，而InnoDB缓存 {索引+数据}<br>  (2) InnoDB 回表需要映射块，而MyISAM 直接映射数据地址<br>  (3) InnoDB 需要维护MVCC机制</p></li></ol><pre><code>    6. MyISAM索引 和 InnoDB 索引 区别    InnoDB 【主键索引】 叶子节点 = &#123;主键ID ， data数据&#125;    因此 InnoDB根据【主键】索引查询，不需要二次寻址，效率更高    InnoDB 【二级索引】 叶子节点 = &#123;key, 主键ID&#125;    如果过实现索引覆盖，即 要查询列值 全部命中索引，则直接返回 非主键索引的内容    如果为实现索引覆盖，则需要根据【主键ID】做回表    【存储结构不同】    InnoDB 存储结构 = 索引和数据 集中存储    MyISAM存储结构 = &#123;表定义，MYD数据文件，MYI索引文件&#125;6. 不带WHERE条件时，【count(*)效率不同 】    MyISAM 自带计数器存储保存【总行数】，可直接返回结果    InnoDB 扫描全表计算总行数    </code></pre><a id="more"></a><h3 id="二-事务特性"><a href="#二-事务特性" class="headerlink" title="二. 事务特性"></a>二. <a href="https://www.zhihu.com/search?type=content&q=%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7">事务特性</a></h3><p>事务符合 ACID原则的一组操作 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. Atomicity</span><br><span class="line">    事务是不可分割的最小单元，事务内所有操作要么全部执行成功，要么全部失败回滚</span><br><span class="line"></span><br><span class="line">2. Isolation</span><br><span class="line">    事务所作出的修改，在提交前，对于其他事务而言不可见</span><br><span class="line">    </span><br><span class="line">3. Durability</span><br><span class="line">    事务一旦提交，所作出的修改是永久的。</span><br><span class="line">    </span><br><span class="line">4. Consistency</span><br><span class="line">    系统从一个正确状态--&gt;另一个正确状态</span><br><span class="line">    AID是数据库的特征，通过AID手段保证C这个目的</span><br><span class="line">    </span><br><span class="line">   【数据库】约束列值 不能小于0，则事务执行失败</span><br><span class="line">   【应用层】约束 余额数据不能小于0，则应用层通过事务回滚保证约束</span><br><span class="line">   </span><br><span class="line">   没有约束，则事务执行成功，且保持了一致性。因为没有破坏约束。</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="三-并发事务带来的问题-1630-1700"><a href="#三-并发事务带来的问题-1630-1700" class="headerlink" title="三. 并发事务带来的问题 1630 - 1700"></a>三. 并发事务带来的问题 1630 - 1700</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 脏读 </span><br><span class="line">    事务A 修改数据，但并未commit。而事务B读取该数据。 </span><br><span class="line">2. 丢失修改</span><br><span class="line">    事务A 、B都读取同一个数据。事务A 、B先后修改数据，则 第一次修改操作丢失。</span><br><span class="line">3. 不可重复读</span><br><span class="line">    事务A 共读取两次数据，而在这两次读取之间。事务B修改了数据。则事务A两次读取到的数据不同。</span><br><span class="line">4. 幻读 </span><br><span class="line">    事务A 读取【n行数据】,事务B在n行数据间添加数据。则事务A第二次读取时，读取到n+1行。</span><br></pre></td></tr></table></figure><h4 id="！！四-事务隔离级别-1801"><a href="#！！四-事务隔离级别-1801" class="headerlink" title="！！四.  事务隔离级别 1801"></a>！！四.  事务隔离级别 1801</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. Read-Uncommitted 读取未提交</span><br><span class="line">    无论事务是否提交，直接【读取主记录】 </span><br><span class="line">    即并发问题 &#x3D;【脏读】+【不可重复读】+【幻影读】</span><br><span class="line">2. Read-committed 读取已提交</span><br><span class="line">    【读取最新版本的快照】，快照是事务提交后产生，但可能存在同一事务两次读取的快照不同。</span><br><span class="line">    即并发问题 &#x3D; 【不可重复读】+【幻影读】</span><br><span class="line">3. Repeatable 可重复读</span><br><span class="line">    【读取指定版本快照】，则事务多次读取某数据行的结果一致，但读取到的数据可能并非最新数据 。</span><br><span class="line">    即并发问题 &#x3D; 【幻影读】</span><br><span class="line">4. Serializable 可串行化 </span><br><span class="line">    上表锁，读写相互阻塞。效率低下。</span><br><span class="line">    无并发问题 </span><br><span class="line">    </span><br><span class="line">InnoDB引擎默认实现 可重复读隔离级别 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="！！五-MVCC-1655"><a href="#！！五-MVCC-1655" class="headerlink" title="！！五. MVCC 1655"></a>！！五. MVCC 1655</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【目的】 ： </span><br><span class="line">    MVCC是行锁的变种，它想要尽可能地避免加锁操作，实现【非阻塞】读。从而提高处理并发事务的性能</span><br><span class="line"></span><br><span class="line">【MVCC 实现的隔离级别】</span><br><span class="line">    MVCC仅 Read Committed &amp; REPEATABLE READ 两种隔离级别</span><br><span class="line">    READ UNCOMMITTED 总是【读取最新】数据行 ，与MVCC的版本快照机制不符</span><br><span class="line">    SERIALIZABLE 则 对读取的【数据行】都加锁 ，与MVCC 尽可能避免加锁的原则不符</span><br><span class="line">    </span><br><span class="line">【undolog】 记录数据行的某个历史版本，undolog以链表形式存在</span><br><span class="line"></span><br><span class="line">RC 是读取 最新版本的 undolog</span><br><span class="line">RR 是读取 某一指定老版本的undolog</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="！！-六-索引"><a href="#！！-六-索引" class="headerlink" title="！！ 六. 索引"></a>！！ 六. 索引</h4><p>索引的存储结构 = {<br>    1. Hash表<br>    2. B+树<br>}</p><h5 id="！6-1-hash索引"><a href="#！6-1-hash索引" class="headerlink" title="！6.1 hash索引"></a>！6.1 hash索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1) hash 索引的实现 </span><br><span class="line">    底层数据结构 &#x3D; hash表</span><br><span class="line">    通过hash值定位数据行，产生碰撞则采用拉链法解决。</span><br><span class="line">(2) hash索引的缺点 </span><br><span class="line">    1. 适用于等值查询。</span><br><span class="line">       但hash索引无法排序，因此不适用于范围查询，不支持最左匹配原则。</span><br><span class="line">    2. 大量重复的键值，减低效率、</span><br></pre></td></tr></table></figure><h5 id="6-2-磁盘预读取"><a href="#6-2-磁盘预读取" class="headerlink" title="6.2 磁盘预读取"></a>6.2 磁盘预读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">磁盘读取以【磁盘块】为基本单位。</span><br><span class="line">【磁盘预读取】：每次读取多个【物理连续】的磁盘块</span><br><span class="line">B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。</span><br><span class="line">一页空间 &#x3D; 磁盘预读取的 多个磁盘块总和</span><br><span class="line">从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="！！6-3-为什么使用B-树，而不是-B树"><a href="#！！6-3-为什么使用B-树，而不是-B树" class="headerlink" title="！！6.3 为什么使用B+树，而不是 B树 "></a>！！6.3 <a href="https://blog.csdn.net/qq_21993785/article/details/80580679">为什么使用B+树，而不是 B树 </a></h5><pre><code>1.  Mysql根据【磁盘IO次数】衡量查询效率，而【B+树磁盘IO次数更少】    因为 B+树中【 非叶节点 = &#123; 指针+key &#125; 】    而B树中 【非叶节点 = &#123; 指针+ key + data数据 &#125;】,    每个节点(即每一页) 存储空间有限，B树节点存储的key较少，出度较小    因此B树的节点较多(key总量固定)    导致B树深度较大，磁盘IO次数多。2.  B+树叶子节点通过指针连接，便于【区间访问】</code></pre><h5 id="！！6-4-为什么使用-B-树，而不是红黑树"><a href="#！！6-4-为什么使用-B-树，而不是红黑树" class="headerlink" title="！！6.4 为什么使用 B+树，而不是红黑树"></a>！！6.4 为什么使用 B+树，而不是红黑树</h5><pre><code>【B+树磁盘IO次数更少】 1.  红黑树的深度往往较大，而磁盘IO次数是和树高度成正比。2.      B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。    一页空间 = 磁盘预读取的 多个磁盘块总和    从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数    红黑树上逻辑较近的节点，其物理距离可能较远。无法利用磁盘预读特性</code></pre><h2 id="​"><a href="#​" class="headerlink" title="​        "></a>​        </h2><h5 id="6-5-聚簇索引和-非聚簇索引-主键索引和二级索引"><a href="#6-5-聚簇索引和-非聚簇索引-主键索引和二级索引" class="headerlink" title="!! 6.5 聚簇索引和 非聚簇索引  主键索引和二级索引"></a>!! 6.5 聚簇索引和 非聚簇索引  主键索引和二级索引</h5><h5 id="聚簇索引和非聚簇索引-【区别】"><a href="#聚簇索引和非聚簇索引-【区别】" class="headerlink" title="聚簇索引和非聚簇索引 【区别】"></a>聚簇索引和非聚簇索引 【区别】</h5><h6 id="聚簇索引-将索引结构和数据放在一起的索引"><a href="#聚簇索引-将索引结构和数据放在一起的索引" class="headerlink" title="聚簇索引 = 将索引结构和数据放在一起的索引"></a>聚簇索引 = 将索引结构和数据放在一起的索引</h6><pre><code>【优点】：查询效率高，定位到索引树叶节点，就直接找到数据【缺点】： 索引列更新时，维护代价大【主键索引】属于【聚簇索引】</code></pre><hr><h6 id="非聚簇索引-索引结构和数据分离的索引"><a href="#非聚簇索引-索引结构和数据分离的索引" class="headerlink" title="非聚簇索引 = 索引结构和数据分离的索引"></a>非聚簇索引 = 索引结构和数据分离的索引</h6><pre><code>【优点】： 更新代价小 【缺点】： 需要二次查询，        例如 二级索引需要在主键索引中再次回表查询【二级索引】属于【非聚簇索引】</code></pre><hr><h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主键索引 叶子节点 &#x3D; &#123;key,其他data数据&#125; </span><br><span class="line"></span><br><span class="line">InnoDB中如果没有指定表的主键，则检测表是否有唯一索引</span><br><span class="line">如果有，则该字段默认 &#x3D; 主键</span><br><span class="line">如果没有， 则InnoDB自动创建6B的自增主键</span><br></pre></td></tr></table></figure></code></pre><hr><h6 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二级索引 叶子节点 &#x3D; &#123;key，主键ID&#125;</span><br><span class="line"></span><br><span class="line">二级索引查询【过程】</span><br><span class="line">    1. 【非聚集索引】中查询到主键ID</span><br><span class="line">    2. 【回表】 ： 根据主键ID在  【聚集索引】中查询整行记录</span><br></pre></td></tr></table></figure></code></pre><h2 id="​-1"><a href="#​-1" class="headerlink" title="​        "></a>​        </h2><h5 id="6-6-最左前缀"><a href="#6-6-最左前缀" class="headerlink" title="!! 6.6 最左前缀"></a>!! 6.6 最左前缀</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">联合索引 是由多个列组成。如(name,age)</span><br><span class="line">查询时，列值【从左到右】匹配索引。</span><br><span class="line">遇到【范围查询】(&gt; &lt; between like左匹配)后 ，不可进一步匹配。</span><br></pre></td></tr></table></figure><p>​    </p><h5 id="6-7-覆盖索引"><a href="#6-7-覆盖索引" class="headerlink" title="6.7 覆盖索引"></a>6.7 覆盖索引</h5><pre><code>在非聚集索引的叶子节点中 所含的列值是要查询的列值，不用进行回表。直接返回即可</code></pre><h5 id="6-8-为什么不对每个列创建索引"><a href="#6-8-为什么不对每个列创建索引" class="headerlink" title="6.8 为什么不对每个列创建索引"></a>6.8 为什么不对每个列创建索引</h5><pre><code>1. 数据CRUD时， 索引需要动态维护2. 索引占据物理空间，尤其聚簇索引</code></pre><hr><h4 id="七-数据库三大范式"><a href="#七-数据库三大范式" class="headerlink" title="七.  数据库三大范式"></a>七.  数据库三大范式</h4><p>第一范式： 每个列不可分离<br>第二范式： 非主键<strong>完全依赖</strong>主键<br>第三范式： 非主键<strong>只依赖</strong>主键，不依赖非主键</p><h4 id="八-索引应用场景"><a href="#八-索引应用场景" class="headerlink" title="八. 索引应用场景"></a>八. 索引应用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE add index(字段名) 创建索引</span><br><span class="line">    1. WHERE </span><br><span class="line">    WHERE 筛选字段进行查询时，</span><br><span class="line">    如果 该字段建立索引，则查询效率更高</span><br><span class="line">    </span><br><span class="line">    2. ORDER BY  </span><br><span class="line">   </span><br><span class="line">    使用order by将查询结果按照某个字段排序时，</span><br><span class="line">    </span><br><span class="line">    如果该字段没有建立索引，</span><br><span class="line">    查询出的所有数据使用外部排序，涉及磁盘IO，则效率底下</span><br><span class="line">    </span><br><span class="line">    ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br><span class="line">    由于索引有序，所以按照索引顺序逐条读出数据</span><br><span class="line">    </span><br><span class="line">    3. 索引覆盖</span><br><span class="line">    【查询的字段】都建立过索引，</span><br><span class="line">    引擎会直接在索引表中查询而【不访问原始数据】</span><br><span class="line">    尽可能在select后只写必要的查询字段，以增加索引覆盖的几率</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="九-创建索引的原则"><a href="#九-创建索引的原则" class="headerlink" title="九. 创建索引的原则"></a>九. 创建索引的原则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 字段 基数大</span><br><span class="line">2. 字段 重复值较少 </span><br><span class="line">3. 字段 频繁作为【查询条件】</span><br><span class="line">4. 字段 更新少 </span><br><span class="line">5. 最左匹配原则 ：  </span><br><span class="line">    MySQL对 索引中的列值 从左到右匹配，直到遇到范围查询就停止</span><br><span class="line">6. 尽量扩展索引，而非创建新索引</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="十-大表优化"><a href="#十-大表优化" class="headerlink" title="十.  大表优化"></a>十.  大表优化</h4><h5 id="explain-查看执行计划-，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等"><a href="#explain-查看执行计划-，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等" class="headerlink" title="explain 查看执行计划 ，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等"></a>explain 查看执行计划 ，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</h5><h5 id="1-大表优化"><a href="#1-大表优化" class="headerlink" title="1. 大表优化"></a>1. 大表优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 限定数据范围 </span><br><span class="line">    查询语句 通过查询条件限定数据范围</span><br><span class="line">2. 数据库主从同步，读写分离</span><br><span class="line">    多个服务器上部署mysql，</span><br><span class="line">    一台服务器为【主库】，负责【写数据】</span><br><span class="line">    其他服务器为【从库】，负责【读数据】</span><br><span class="line">    </span><br><span class="line">    一. 主从同步实现</span><br><span class="line">    【主库A】数据库事件存储在 日志系统A中，传输日志文件</span><br><span class="line">    【从库】 接收文件并写入本地日志系统，然后将【数据库事件】在从库MySQL中完成</span><br><span class="line"></span><br><span class="line">3. 垂直分区</span><br><span class="line">    </span><br><span class="line">    优点：一行记录 的数据量变少，在查询时IO次数减少</span><br><span class="line">    </span><br><span class="line">    缺点：</span><br><span class="line">        (1) 主键冗余，</span><br><span class="line">        (2) 引起join操作</span><br><span class="line">4. 水平分区</span><br><span class="line">    将 【行数据】分组存储到不同【库 ||表】， 【最好分库】</span><br><span class="line">    </span><br><span class="line">    【缺点】：</span><br><span class="line">        (1) 查询时，通常需要 【多个表名】 + 【UNION操作】</span><br><span class="line">        (2) 跨库 JOIN 性能很差 , </span><br><span class="line">        (3) 【跨库】的【事务支持】，逻辑复杂度和性能代价 都很大</span><br><span class="line"></span><br><span class="line">            </span><br></pre></td></tr></table></figure><hr><h5 id="2-分表-分库后的问题"><a href="#2-分表-分库后的问题" class="headerlink" title="2. 分表 分库后的问题"></a>2. 分表 分库后的问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1). 【跨节点】的 count，order by ， group by 等【聚合函数】逻辑复杂</span><br><span class="line">(2). 【跨库】的join 性能代价大</span><br><span class="line">(3). 【主键ID问题】 ：MySQL原先主键自增机制，跨库情况下，存在主键重复的问题</span><br><span class="line">   1)  若采用 UUID作为主键， 则UUID主键占用内存过大</span><br><span class="line">   2)  多个数据库采用 跨步自增</span><br><span class="line">   3) ...</span><br><span class="line">(4) 【事务支持】</span><br></pre></td></tr></table></figure><hr><h5 id="3-主从分布，读写分离"><a href="#3-主从分布，读写分离" class="headerlink" title="3. 主从分布，读写分离"></a>3. 主从分布，读写分离</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用 &#x3D; &#123; 负载均衡 + 数据备份 + 高可用&#125;</span><br><span class="line">流程 &#x3D;&#123;</span><br><span class="line">    1. 主库的【数据库事件】记录在二进制的binlog，binlog传输给从库</span><br><span class="line">    2. 从库读取binlog内容到本地日志系统的relaylog</span><br><span class="line">    3. 从库 执行relay log中的SQL语句，实现主从同步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十一-SQL生命周期"><a href="#十一-SQL生命周期" class="headerlink" title="十一. SQL生命周期"></a>十一. SQL生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 应用服务器与数据库服务器建立一个连接，应用服务器发送SQL请求</span><br><span class="line"></span><br><span class="line">2. 数据库进程拿到【sql请求】，通过【连接器】验证SQL语句是否具有【权限】</span><br><span class="line"></span><br><span class="line">3. 【分析器】进行 词法分析和语法分析。 </span><br><span class="line">    词法分析 提取SQL语句关键元素 ： SELECT 、 表名 、 查询条件等</span><br><span class="line">    语法分析 判断SQL语句是否正确 ：判断关键词是否正确</span><br><span class="line"></span><br><span class="line">4. 【优化器】生成SQL【执行计划】</span><br><span class="line">    </span><br><span class="line">5. 【执行器】按照执行计划， 将数据读取到内存并进行逻辑处理</span><br><span class="line"></span><br><span class="line">6. 通过连接，将数据传输给应用服务器 </span><br><span class="line"></span><br><span class="line">7. 断开连接</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="十二-MySQL锁"><a href="#十二-MySQL锁" class="headerlink" title="十二. MySQL锁"></a>十二. MySQL锁</h4><h5 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1. 表锁"></a>1. 表锁</h5><h5 id="2-行锁"><a href="#2-行锁" class="headerlink" title="2. 行锁"></a>2. 行锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Record Lock :  单个数据行的锁</span><br><span class="line">2. Gap Lock ： 锁定范围，不包括记录本身</span><br><span class="line">3. Next-key lock : record + gap 结合，锁定一个范围，并且锁定记本身</span><br></pre></td></tr></table></figure><h4 id="十三-count-count1-count-col-区别-1050-1110"><a href="#十三-count-count1-count-col-区别-1050-1110" class="headerlink" title="十三. count* count1 count(col)区别  1050 - 1110"></a>十三. count* count1 count(col)区别  1050 - 1110</h4><h5 id="count-expression-聚合函数"><a href="#count-expression-聚合函数" class="headerlink" title="count(expression) = 聚合函数"></a>count(expression) = 聚合函数</h5><pre><code>逐行检测expression是否=null, expression！=null则计数器加1</code></pre><h5 id="count-1-和count-作用相同"><a href="#count-1-和count-作用相同" class="headerlink" title="count(1)和count(*)作用相同:"></a>count(1)和count(*)作用相同:</h5><pre><code>count(1) 每行expression=1 ，NOT NULL，count(1)作用=统计总行数count(*) 并非 统计每行所有列值是否为null，列值全为null的数据行不存在.因此 count(*) = 统计总行数</code></pre><h5 id="count-1-count-经过优化器指定的执行计划相同-，两者效率相同"><a href="#count-1-count-经过优化器指定的执行计划相同-，两者效率相同" class="headerlink" title="count(1) count(*) 经过优化器指定的执行计划相同 ，两者效率相同"></a>count(1) count(*) 经过优化器指定的执行计划相同 ，两者效率相同</h5><pre><code>在没有二级索引情况下， 通过主键索引统计总行数如果有二级索引， 则优先选择 【最窄】二级索引统计总行数 主键索引 叶节点 = &#123;主键ID, 其他所有列值&#125;二级索引 叶节点 = &#123;key+主键ID&#125; </code></pre><h5 id="count-col-逐行检测col是否-null"><a href="#count-col-逐行检测col是否-null" class="headerlink" title="count(col) 逐行检测col是否=null"></a>count(col) 逐行检测col是否=null</h5><pre><code>因此 count(col)统计 非null列的总行数对col建立非聚集索引，可以优化查询效率</code></pre><h4 id="十四-explain-返回的结果"><a href="#十四-explain-返回的结果" class="headerlink" title="十四. explain 返回的结果"></a>十四. <a href="https://blog.csdn.net/zhuxineli/article/details/14455029">explain 返回的结果</a></h4><h5 id="type-【引擎查找表】的方式"><a href="#type-【引擎查找表】的方式" class="headerlink" title="type 【引擎查找表】的方式"></a>type 【引擎查找表】的方式</h5><pre><code>all,index,range,ref,eq_ref，const从左到右，它们的效率依次是增强的all     全表扫描index   全索引扫描range   范围扫描 ：     【索引】+【范围查询】ref     小范围扫描：    【可能重复】的【普通索引】+【表联结情况】eq_ref  单条数据扫描 ： 【主键 || 唯一】索引+【表联结情况】const   单条数据扫描 ： 【主键 || 唯一】索引 </code></pre><p>​    </p><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><pre><code>MySQL 使用的索引</code></pre><h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><pre><code>MYSQL 执行查询的行数，数值越大性能越差 </code></pre><h5 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h5><pre><code>Using index 使用覆盖索引Using Where 使用WHERE过滤Using temporary ： 使用临时表 ，建议优化Using filesort ： 对查询结果【外部排序】，而非根据索引有序读取。建议优化 </code></pre><hr><h4 id="十五-SQL优化-1020"><a href="#十五-SQL优化-1020" class="headerlink" title="十五. SQL优化 1020"></a>十五. SQL优化 1020</h4><h4 id="一-WHERE的优化"><a href="#一-WHERE的优化" class="headerlink" title="(一). WHERE的优化"></a>(一). WHERE的优化</h4><h5 id="1-全表扫描"><a href="#1-全表扫描" class="headerlink" title="1.全表扫描"></a>1.全表扫描</h5><p>WHERE,ORDER BY涉及的列上 建立索引 </p><h5 id="2-WHERE条件中避免使用的判断"><a href="#2-WHERE条件中避免使用的判断" class="headerlink" title="2.WHERE条件中避免使用的判断"></a>2.WHERE条件中避免使用的判断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    is null ,</span><br><span class="line">    !&#x3D;  ,</span><br><span class="line">    OR  ,</span><br><span class="line">    in  ,   &#x2F;&#x2F;  慎重使用，非连续 in集合会放弃索引，全表扫描</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些判断，会使得引擎【放弃索引】，进行【全表扫描】</p><h5 id="3-WHERE条件中-避免【运行时解析】的变量"><a href="#3-WHERE条件中-避免【运行时解析】的变量" class="headerlink" title="3. WHERE条件中 避免【运行时解析】的变量"></a>3. WHERE条件中 避免【运行时解析】的变量</h5><p>原因： 执行计划在【<strong>编译期</strong>】制定，【<strong>运行时解析</strong>】的变量不能作为索引输入项<br>因此采用全表扫描  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    1. 参数 </span><br><span class="line">         WHERE num &#x3D; @num</span><br><span class="line">    2. WHERE条件左侧 避免 函数调用+算术计算 </span><br><span class="line">        WHERE num &#x3D; 100+2</span><br><span class="line">        WHERE substring(num,1,3) &#x3D; &#39;abc&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="十六-超大分页"><a href="#十六-超大分页" class="headerlink" title="十六. 超大分页"></a>十六. 超大分页</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">超大分页 &#x3D; Limit 10000，10 </span><br><span class="line">MySQL并非跳过&#x3D; offset行，而是取offset+N行，然后返回放弃前offset行，返回N行</span><br><span class="line">那当offset特别大的时候，效率低下</span><br><span class="line"></span><br><span class="line">【优化方法】： 先快速定位 主键，然后再关联</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="十七-SQL优化"><a href="#十七-SQL优化" class="headerlink" title="十七. SQL优化"></a>十七. SQL优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 慢查询日志 ，查看开销大的SQL</span><br><span class="line">    set GLOBAL slow_query_log &#x3D; on</span><br><span class="line">2.  开销大原因 &#x3D; &#123;</span><br><span class="line">    1.  </span><br><span class="line">        【原因一】：SQL语句 是否加载额外的数据 </span><br><span class="line">        【例子】： 未使用WHERE范围限制、 Limit分页过大、 使用&#123;is NULL，!&#x3D; ，OR&#125; 触发全表扫描</span><br><span class="line">        【优化】 ： 修改SQL语句</span><br><span class="line">        </span><br><span class="line">    2. </span><br><span class="line">        【原因二】： 未命中索引、使用的索引有待优化</span><br><span class="line">        【例子】： SELECT A,B,C FROM t WHERE A&#x3D;? AND B&#x3D; ? </span><br><span class="line">                    或者 ORDER BY 、ON的列上是否建立索引 </span><br><span class="line">        【优化】：explain查询执行计划，创建||选择其他索引，使得SQL语句尽可能地命中索引</span><br><span class="line">        </span><br><span class="line">    3. </span><br><span class="line">        【原因三】： SQL语句无法优化，【大表情况】</span><br><span class="line">            (1) 分库分表</span><br><span class="line">            (2) 主从同步，读写分离</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></font>]]></content>
    
    
    <summary type="html">&lt;font size=&quot;3&quot;&gt;

&lt;h3 id=&quot;一-mysql存储引擎-MyISAM-和-InnoDB的区别&quot;&gt;&lt;a href=&quot;#一-mysql存储引擎-MyISAM-和-InnoDB的区别&quot; class=&quot;headerlink&quot; title=&quot;一. mysql存储引擎 = { MyISAM 和 InnoDB的区别}&quot;&gt;&lt;/a&gt;一. mysql存储引擎 = { MyISAM 和 InnoDB的区别}&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;【是否支持行锁】&lt;br&gt;  MyISAM 仅支持表锁， InnoDB支持表锁和行锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【是否支持事务】&lt;br&gt;  MyISAM不支持事务，且不具备【崩溃恢复能力】。&lt;br&gt;  InnoDB 支持事务，提供回滚和崩溃恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【是否支持外键】&lt;br&gt;  仅InnoDB支持外键 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【是否支持MVCC】&lt;br&gt;  仅InnoDB支持MVCC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【应用场景不同】&lt;br&gt;  MyISAM 适用 【Select】频繁，并发少&lt;br&gt;  InnoDB 适用 【Insert Delete Update】频繁，高并发&lt;/p&gt;
&lt;p&gt;  因为&lt;br&gt;  (1) MyISAM 仅缓存索引块，而InnoDB缓存 {索引+数据}&lt;br&gt;  (2) InnoDB 回表需要映射块，而MyISAM 直接映射数据地址&lt;br&gt;  (3) InnoDB 需要维护MVCC机制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    6. MyISAM索引 和 InnoDB 索引 区别

    InnoDB 【主键索引】 叶子节点 = &amp;#123;主键ID ， data数据&amp;#125;
    因此 InnoDB根据【主键】索引查询，不需要二次寻址，效率更高

    InnoDB 【二级索引】 叶子节点 = &amp;#123;key, 主键ID&amp;#125;
    如果过实现索引覆盖，即 要查询列值 全部命中索引，则直接返回 非主键索引的内容
    如果为实现索引覆盖，则需要根据【主键ID】做回表

    【存储结构不同】
    InnoDB 存储结构 = 索引和数据 集中存储
    MyISAM存储结构 = &amp;#123;表定义，MYD数据文件，MYI索引文件&amp;#125;

6. 不带WHERE条件时，【count(*)效率不同 】
    MyISAM 自带计数器存储保存【总行数】，可直接返回结果
    InnoDB 扫描全表计算总行数    &lt;/code&gt;&lt;/pre&gt;&lt;/font&gt;</summary>
    
    
    
    
    <category term="基础编程知识学习" scheme="https://github.com/lzhello/lzhello.github.io.git/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>firstblog</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2020/11/12/firstblog/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2020/11/12/firstblog/</id>
    <published>2020-11-12T11:43:38.000Z</published>
    <updated>2021-02-18T16:18:43.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的博客文章"><a href="#我的博客文章" class="headerlink" title="我的博客文章"></a>我的博客文章</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标记（-后面一定要加空格）"><a href="#这是一个三级标记（-后面一定要加空格）" class="headerlink" title="这是一个三级标记（#后面一定要加空格）"></a>这是一个三级标记（#后面一定要加空格）</h3><p><em>这一句话会是斜体</em></p><p><strong>这一句话会被加粗</strong></p><p><strong><em>这一句话会被斜体加粗</em></strong></p><p><del>这一句话会有删除线</del></p><blockquote><p>这里是引用的内容</p><blockquote><p>还能接着引用</p><blockquote><p>还能再往里引用</p></blockquote></blockquote></blockquote><a id="more"></a><p>接下来是分割线</p><hr><hr><h3 id="这里是超链接"><a href="#这里是超链接" class="headerlink" title="这里是超链接"></a>这里是超链接</h3><p><a href="http://baidu.com/">百度</a></p><h3 id="这里是无序列表"><a href="#这里是无序列表" class="headerlink" title="这里是无序列表"></a>这里是无序列表</h3><ul><li>列表1</li></ul><ul><li>列表2</li></ul><ul><li>列表3<ul><li>列表嵌套（前加三个空格）</li></ul></li></ul><h3 id="这里是有序列表"><a href="#这里是有序列表" class="headerlink" title="这里是有序列表"></a>这里是有序列表</h3><ol><li>列表1</li><li>列表2</li><li>列表3</li></ol><h3 id="这里是表格"><a href="#这里是表格" class="headerlink" title="这里是表格"></a>这里是表格</h3><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h3 id="这里是代码"><a href="#这里是代码" class="headerlink" title="这里是代码"></a>这里是代码</h3><p><code>printf(&#39;hello,world);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">     System.out.println(&quot;hello,world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;我的博客文章&quot;&gt;&lt;a href=&quot;#我的博客文章&quot; class=&quot;headerlink&quot; title=&quot;我的博客文章&quot;&gt;&lt;/a&gt;我的博客文章&lt;/h1&gt;&lt;h2 id=&quot;这是一个二级标题&quot;&gt;&lt;a href=&quot;#这是一个二级标题&quot; class=&quot;headerlink&quot; title=&quot;这是一个二级标题&quot;&gt;&lt;/a&gt;这是一个二级标题&lt;/h2&gt;&lt;h3 id=&quot;这是一个三级标记（-后面一定要加空格）&quot;&gt;&lt;a href=&quot;#这是一个三级标记（-后面一定要加空格）&quot; class=&quot;headerlink&quot; title=&quot;这是一个三级标记（#后面一定要加空格）&quot;&gt;&lt;/a&gt;这是一个三级标记（#后面一定要加空格）&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这一句话会是斜体&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这一句话会被加粗&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这一句话会被斜体加粗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;这一句话会有删除线&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还能接着引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还能再往里引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/lzhello/lzhello.github.io.git/2020/11/12/hello-world/"/>
    <id>https://github.com/lzhello/lzhello.github.io.git/2020/11/12/hello-world/</id>
    <published>2020-11-12T08:42:59.216Z</published>
    <updated>2020-11-12T08:42:59.216Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
